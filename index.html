<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARKER</title>
    <!-- Fonts -->
    <link rel="preload" href="./assets/fonts/Presicav.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="./assets/fonts/Calibre-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="./assets/fonts/Arial.woff2" as="font" type="font/woff2" crossorigin="anonymous">

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://api.fontshare.com/v2/css?f[]=neue-montreal@500&display=swap" rel="stylesheet">

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    <script src="https://unpkg.com/lenis@1.1.20/dist/lenis.min.js"></script>
    <script type="module" crossorigin src="./js/index.min.js?v=1754734869502"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

    <link rel="stylesheet" crossorigin href="./css/index.min.css?v=1754734869502">
    <link rel="stylesheet" href="./style.css">

</head>

<body class="is-loading">

    <canvas id="global-cursor-canvas"></canvas>

    <div id="threejs-marker-container"></div>
    <section class="loader-screen">
        <div class="loader-content">
            <div class="willem__h1">
                <div class="willem__h1-start">
                    <span class="willem__letter">M</span>
                    <span class="willem__letter">A</span>
                    <span class="willem__letter">R</span>
                </div>
                <div class="willem-loader__box">
                    <div class="willem-loader__box-inner">
                        <div class="willem__growing-image">
                            <div class="willem__growing-image-wrap">
                                <img class="willem__cover-image-extra is--1" src="./assets/marker1.jpg" loading="lazy"
                                    alt="">
                                <img class="willem__cover-image-extra is--2" src="./assets/marker2.jpeg" loading="lazy"
                                    alt="">
                                <img class="willem__cover-image-extra is--3" src="./assets/marker3.webp" loading="lazy"
                                    alt="">
                                <img class="willem__cover-image" src='./assets/white.png' loading="lazy" alt="">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="willem__h1-end">
                    <span class="willem__letter">K</span>
                    <span class="willem__letter">E</span>
                    <span class="willem__letter">R</span>
                </div>
            </div>
        </div>
    </section>

    <div class="wrapper">
        <header class="header fade" data-fls-header="" data-fls-header-scroll="" data-fls-header-scroll-show="">
            <div class="header__container">
                <div class="header__menu menu">
                    <h1 class="logo">
                        <a href="#">MARKER</a>
                    </h1>
                </div>
            </div>
        </header>

        <main class="page page--home">

            <section class="hero">
                <video class="hero__video" src="./files/banner-hero.mov" autoplay muted loop playsinline=""></video>
                <canvas class="hero__canvas" id="hero-canvas"></canvas>
                <h1 class="hero__title">
                    <span>MARKER</span>
                </h1>
            </section>
            <section id="urbanist-integration">
                <svg class="urbanist-bg" width="100%" viewBox="0 0 1920 1300" fill="none"
                    xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none">
                    <rect width="1920" height="1300" fill="url(#gradient)"></rect>
                    <defs>
                        <linearGradient id="gradient" x1="1300.54" y1="201.621" x2="959.727" y2="841.863"
                            gradientUnits="userSpaceOnUse">
                            <stop offset="0.15" stop-color="var(--theme-sub-bg)" stop-opacity="1"></stop>
                            <stop offset="0.85" stop-color="var(--theme-main-bg)"></stop>
                        </linearGradient>
                    </defs>
                </svg>

                <div class="content-layer">
                    <h1>Marker</h1>
                    <p class="desc-1">
                        The Marker font captures the spontaneous energy and look of a broad-tipped permanent
                        marker, offering a bold and authentic hand-drawn aesthetic for digital interfaces.
                    </p>
                    <p class="desc-2">
                        Characterized by its irregular edges, organic flow, and varying stroke weights, it
                        breaks away from rigid digital grids to deliver a raw, human touch.
                    </p>
                    <p class="desc-3">
                        Ideal for impactful headlines and creative overlays, this typeface transforms
                        standard typography into expressive, attention-grabbing visual statements.
                    </p>
                </div>

                <div id="panes-container">
                    <div class="pane">
                        <img class="urbanist-floating-img" src="./assets/blue.png" alt="Marker design inspiration 1">
                    </div>
                    <div class="pane">
                        <img class="urbanist-floating-img" src="./assets/orange.png" alt="Marker design inspiration 2">
                    </div>
                    <div class="pane">
                        <img class="urbanist-floating-img" src="./assets/green.png" alt="Marker design inspiration 3">
                    </div>
                </div>
            </section>
            <section id="grid-scroll-wrapper">
                <section style="margin-bottom: -200px;" class="section-stick">
                    <p class="opacity-reveal reveal-text-style">
                        If you’re bold, a single marker stroke will break the grid, steal the show, and change
                        everything.
                    </p>
                </section>
            </section>
            <div id="alice-wrapper">
                <section class="intro">
                    <h1 class="intro__heading">Marker Colour Priority and Visual Hierarchy</h1>
                </section>
                <section class="content">
                    <article class="article">
                        <h4 style="margin-top: 20px;color: red;"><b>Red Marker (Highest Priority)</b></h4>
                        <p>
                            RED is the most attention-grabbing marker colour. It represents urgency,
                            <b>danger</b>, and high
                            <b>importance</b>,
                            making it ideal for warnings and critical highlights.
                        </p>
                        <p class="mobile-hidden">
                            Its strong visual impact ensures immediate focus, so it is used carefully and with clear
                            intention.
                        </p>

                        <h4 style="margin-top: 20px;color: black;"><b>Black Marker</b></h4>
                        <p>
                            BLACK symbolizes clarity and authority. It is widely used for writing, outlining, and
                            clear
                            <b>communication</b> due to its high readability .
                        </p>
                        <p class="mobile-hidden">
                            Because of its professional appearance, black is preferred for formal and final work.
                        </p>

                        <h4 style="margin-top: 20px;color: blue;"><b>Blue Marker</b></h4>
                        <p>
                            BLUE represents trust and <b>calmness</b>. It is commonly used for general writing
                            and explanations
                            without creating visual stress.
                        </p>
                        <p class="mobile-hidden">
                            This colour is suitable for notes and planning where balance and clarity are needed.
                        </p>

                        <h4 style="margin-top: 20px;color: green;"><b>Green Marker (Lowest Priority)</b></h4>
                        <p>
                            GREEN stands for positivity and <b>approval</b>. It is often used to show
                            <b>correctness</b> or progress.
                        </p>
                        <p class="mobile-hidden">
                            With lower urgency, green works best for supportive and secondary highlights.
                        </p>
                    </article>
                </section>
                <div class="hero-reveal-wrapper">
                    <section class="hero-reveal">
                        <article>
                            <header class="hero-reveal__header">
                                <div class="hero-reveal_split">
                                    <div class="hero-reveal_split_item">
                                        <p>PRIME INK</p>
                                    </div>
                                    <div class="hero-reveal_split_item" aria-hidden="true">
                                        <p aria-hidden="true">PRIME INK</p>
                                    </div>
                                </div>
                            </header>

                            <div class="hero-reveal__content">
                                <div class="hero-reveal__content-inner">
                                    <div class="hero-reveal__parallax">
                                        <img src="https://assets.codepen.io/204808/alice-falling-1.png" alt="Alice"
                                            class="hero-reveal__parallax-alice" />
                                        <img width="150" src="https://assets.codepen.io/204808/alice-falling-clock.png"
                                            alt="Clock" class="hero-reveal__parallax-clock" />
                                        <img width="100" src="https://assets.codepen.io/204808/alice-falling-book.png"
                                            alt="Book" class="hero-reveal__parallax-book" />
                                        <img width="50" src="https://assets.codepen.io/204808/alice-falling-kattle.png"
                                            alt="Kattle" class="hero-reveal__parallax-kattle" />
                                        <img width="330" src="https://assets.codepen.io/204808/alice-falling-card.png"
                                            alt="Card" class="hero-reveal__parallax-card" />
                                    </div>

                                    <div class="hero-reveal__content-p">
                                        <p>
                                            <B>The ink of the marker</B> flowed with confidence, bold and consistent,
                                            leaving
                                            behind a stroke that felt
                                            <B>permanent and intentional</B>. It dried quickly on the surface, resisting
                                            smudges, while the pigment
                                            settled deep into the material, giving the line its strong and lasting
                                            presence.
                                        </p>
                                        <p class="mobile-hidden">
                                            As the marker moved, the ink revealed its character — rich in color,
                                            balanced in density, and smooth
                                            in motion. Each stroke carried clarity, allowing ideas to take shape without
                                            interruption or loss
                                            of control.
                                        </p>
                                        <p>
                                            Unlike ordinary pens, marker ink is designed to command attention. Its
                                            formulation blends pigments
                                            and solvents carefully, ensuring even coverage while maintaining durability
                                            across different
                                            surfaces and textures.
                                        </p>
                                        <p class="mobile-hidden">
                                            <B>“This is not just ink,”</B> the creator realized, <B>“it is expression
                                                itself.”</B>
                                            With every line drawn, the
                                            marker transformed thought into form, leaving marks that spoke with
                                            strength, precision, and purpose.
                                        </p>
                                    </div>

                                </div>
                            </div>
                        </article>
                    </section>
                </div>

            </div>
            <section class="viewport-section intro-viewport">
                <div class="content-wrapper">
                    <h1>A creative marker built for clarity, control, and expression.</h1>
                </div>
            </section>
            <section class="viewport-section narrative-segment scroll-sequence-host">
                <div class="content-wrapper">
                    <div class="kinetic-typography-block">
                        <p>
                            Marker is designed as a focused tool for creators who value precision
                            and intention. Every stroke carries meaning, and every interaction is
                            crafted to feel natural, responsive, and purposeful.
                        </p>
                        <p>
                            More than a simple tool, Marker adapts to your workflow. It gives you
                            control over form, movement, and structure while staying effortless
                            to use. From quick ideas to refined details, Marker supports the way
                            you think and create.
                        </p>
                    </div>
                </div>
            </section>
            <section class="viewport-section action-trigger-zone">
                <div class="content-wrapper">
                    <h1>Create with confidence using Marker's powerful tools.</h1>
                </div>
            </section>
            <section class="viewport-section capabilities-segment scroll-sequence-host">
                <div class="content-wrapper">
                    <div class="kinetic-typography-block">
                        <p>
                            Marker offers smooth interactions, adaptive precision, and intelligent
                            responsiveness in every feature. Whether you are highlighting ideas,
                            shaping concepts, or guiding attention, Marker reacts instantly and
                            accurately to your intent.
                        </p>
                        <p>
                            With optimized performance, flexible controls, and real-time feedback,
                            Marker transforms simple actions into expressive outcomes. It is built
                            to stay out of your way while enhancing every moment of creation.
                        </p>
                    </div>
                </div>
            </section>
            <section class="viewport-section conclusion-viewport">
                <div class="content-wrapper">
                    <h1>Marker empowers creators to define ideas with their purpose.</h1>
                </div>
            </section>

            <style>
                @media (max-width: 768px) {

                    .content-wrapper h1,
                    .kinetic-typography-block p {
                        -webkit-hyphens: none;
                        hyphens: none;
                        word-break: normal;
                    }
                }
            </style>

            <section class="viewport-section"
                style="height: 60vh; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; background: #fff;">



                <div class="magnetic-wrap" id="mag-wrap">
                    <button class="black-hole-btn" id="mag-btn" onclick="goToPlayground()">
                        <span class="btn-text">Enter board</span>
                        <span class="btn-text-hover">Explore</span>
                    </button>
                </div>

                <div class="transition-overlay"></div>

                <script>
                    const magBtn = document.getElementById('mag-btn');
                    const magWrap = document.getElementById('mag-wrap');

                    // Magnetic Effect
                    if (magWrap && magBtn) {
                        magWrap.addEventListener('mousemove', (e) => {
                            const rect = magWrap.getBoundingClientRect();
                            const x = e.clientX - rect.left - rect.width / 2;
                            const y = e.clientY - rect.top - rect.height / 2;

                            // Move button towards cursor (0.3 strength)
                            gsap.to(magBtn, {
                                x: x * 0.3,
                                y: y * 0.3,
                                rotation: x * 0.05,
                                duration: 0.6,
                                ease: "power3.out"
                            });

                            // Move text content slightly more for parallax
                            const textProps = magBtn.querySelector('.btn-text');
                            if (textProps) {
                                gsap.to(textProps, {
                                    x: x * 0.1,
                                    y: y * 0.1,
                                    duration: 0.6,
                                });
                            }
                        });

                        magWrap.addEventListener('mouseleave', () => {
                            gsap.to(magBtn, { x: 0, y: 0, rotation: 0, duration: 1, ease: "elastic.out(1, 0.5)" });
                            const textProps = magBtn.querySelector('.btn-text');
                            if (textProps) gsap.to(textProps, { x: 0, y: 0, duration: 1 });
                        });
                    }

                    function goToPlayground() {
                        const overlay = document.querySelector('.transition-overlay');
                        const btn = document.getElementById('mag-btn');

                        // 1. Explode/Scale Button
                        if (btn) {
                            gsap.to(btn, {
                                scale: 20, // Expand to fill screen? No, let's just pop it
                                opacity: 0,
                                duration: 0.4,
                                ease: "power2.in"
                            });
                        }

                        // 2. Curtain Rise
                        if (overlay) {
                            gsap.set(overlay, { transformOrigin: "bottom" });
                            gsap.to(overlay, {
                                scaleY: 1,
                                duration: 0.8,
                                ease: "power4.inOut",
                                onComplete: () => {
                                    window.location.href = 'playground.html';
                                }
                            });
                        } else {
                            // Fallback
                            window.location.href = 'playground.html';
                        }
                    }
                </script>
            </section>

            <footer id="exact-footer">

                <div class="top-row">
                    <h1 class="headline-text">
                        LEAVE YOUR <br> MARK.
                    </h1>
                </div>

                <div class="main-grid">

                    <div class="grid-col col-cta">
                        <div class="col-content top">
                            <span class="label-text">START A PROJECT</span>
                            <h2 class="sub-heading">Have an <br> idea?</h2>
                        </div>

                        <div class="col-content bottom">
                            <a href="mailto:hello@marker.com" class="red-circle-cta">
                                <span class="cta-line">LET'S TALK</span>
                                <span class="cta-line">EMAIL ME</span>
                            </a>
                        </div>
                    </div>

                    <div class="grid-col col-dir">
                        <div class="dir-header">
                            <span class="label-text">DIRECTORY</span>
                            <div class="pulsing-dot"></div>
                        </div>

                        <ul class="dir-links">
                            <li><a href="#">Index</a></li>
                            <li><a href="#">Case Studies</a></li>
                            <li><a href="#">About Marker</a></li>
                            <li><a href="#">Documentation</a></li>
                            <li><a href="#">Playground</a></li>
                        </ul>
                    </div>

                    <div class="grid-col col-net">

                        <div class="net-section">
                            <span class="label-text">NETWORK</span>
                            <div class="pill-container">
                                <a href="#" class="pill-btn">Instagram ↗</a>
                                <a href="#" class="pill-btn">Twitter (X) ↗</a>
                                <a href="#" class="pill-btn">LinkedIn ↗</a>
                                <a href="#" class="pill-btn">GitHub ↗</a>
                            </div>
                        </div>

                        <div class="input-section">
                            <span class="label-text">STAY IN THE LOOP</span>
                            <form class="loop-form">
                                <input type="email" placeholder="ENTER_EMAIL_ADDRESS" required>
                                <button type="submit" class="enter-icon">↵</button>
                            </form>
                        </div>
                    </div>

                </div>

                <div class="bottom-bar">
                    <div class="meta-item left">
                        <span class="red-dot">●</span>
                        <span id="exact-time">17:33:19</span>
                    </div>
                    <div class="meta-item center">
                        <span>LOCAL: INDIA</span>
                    </div>
                    <div class="meta-item right">
                        <span>© 2026 MARKER.</span>
                    </div>
                </div>

            </footer>
            <script>document.addEventListener("DOMContentLoaded", () => {
                    function updateExactTime() {
                        const timeEl = document.getElementById("exact-time");
                        if (timeEl) {
                            const now = new Date();
                            // Format to match HH:MM:SS exactly
                            const timeStr = now.toLocaleTimeString('en-GB', {
                                hour12: false,
                                hour: '2-digit',
                                minute: '2-digit',
                                second: '2-digit'
                            });
                            timeEl.textContent = timeStr;
                        }
                    }
                    setInterval(updateExactTime, 1000);
                    updateExactTime();
                });</script>

        </main>
    </div>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            gsap.registerPlugin(ScrollTrigger);

            // Helper function to animate a specific section
            function animateSection(selector) {
                const section = document.querySelector(selector);
                if (!section) return;

                const card = section.querySelector('.content-wrapper');
                const heading = card ? section.querySelector('h1') : null;

                if (!card || !heading) return;

                // --- FIX START: WORD-BASED SPLITTING ---
                // 1. Get the raw text
                const originalText = heading.innerText.trim();

                // 2. Split by spaces to get an array of words
                const words = originalText.split(/\s+/);

                // 3. Rebuild HTML
                // We wrap each word in a <span class="word">
                // We join them back together with a standard space " "
                heading.innerHTML = words.map(word => {
                    // Split the word into chars for the animation
                    const charSpans = word.split('').map(char =>
                        `<span class="char" style="display:inline-block;">${char}</span>`
                    ).join('');

                    // Return the word wrapper
                    return `<span class="word">${charSpans}</span>`;
                }).join(' '); // <--- This ' ' is the break point for the browser
                // --- FIX END ---

                // 2. Timeline
                const tl = gsap.timeline({
                    scrollTrigger: {
                        trigger: section,
                        start: "top 75%",
                        end: "bottom 25%",
                        toggleActions: "play none none reverse"
                    }
                });

                // 3. Card Animation
                tl.fromTo(card,
                    {
                        scale: 0.2,
                        opacity: 0,
                        y: 50,
                        borderRadius: "10rem"
                    },
                    {
                        duration: 1.5,
                        scale: 1,
                        opacity: 1,
                        y: 0,
                        borderRadius: "2rem",
                        ease: "expo.out",
                        clearProps: "all"
                    }
                );

                // 4. Text Animation
                const chars = heading.querySelectorAll(".char");
                if (chars.length > 0) {
                    tl.fromTo(chars,
                        {
                            y: 20,
                            opacity: 0,
                            filter: "blur(10px)"
                        },
                        {
                            duration: 1,
                            y: 0,
                            opacity: 1,
                            filter: "blur(0px)",
                            stagger: 0.02,
                            ease: "power2.out"
                        }, "-=1.2");
                }
            }

            // Explicitly call for each section
            animateSection(".intro-viewport");
            animateSection(".action-trigger-zone");
            animateSection(".conclusion-viewport");

            // Refresh ScrollTrigger
            ScrollTrigger.refresh();
        });
    </script>
    <script>
        // --- 1. TYPED SWAP EFFECT LOGIC ---
        function initTypedSwap() {
            const ATTR = 'data-fls-typed';

            // Helper to split text correctly
            const splitChars = str => {
                return [...str]; // Simple spread for modern browsers
            };

            const parseOpts = root => {
                const def = { duration: 0.45, stagger: 0.03, ease: 'power2.out' };
                const raw = root.getAttribute(ATTR);
                if (raw) {
                    raw.split(';').forEach(p => {
                        const [k, v] = p.split(':').map(s => s.trim());
                        if (k === 'duration') def.duration = parseFloat(v);
                        if (k === 'stagger') def.stagger = parseFloat(v);
                    });
                }
                return def;
            };

            document.querySelectorAll(`[${ATTR}]`).forEach(root => {
                const text = root.textContent.trim();
                root.textContent = '';
                const opt = parseOpts(root);

                // Create Base (Normal) and Alt (Italic/Stroke) layers
                const base = document.createElement('span');
                base.className = 'tsw__base';
                const alt = document.createElement('span');
                alt.className = 'tsw__alt';

                // Inject characters
                splitChars(text).forEach((char, i) => {
                    const s1 = document.createElement('span');
                    s1.className = 'char';
                    s1.textContent = char === ' ' ? '\u00A0' : char;
                    s1.style.transitionDelay = `${i * opt.stagger}s`;

                    const s2 = s1.cloneNode(true);

                    base.appendChild(s1);
                    alt.appendChild(s2);
                });

                root.appendChild(base);
                root.appendChild(alt);
            });
        }

        // --- 2. GSAP FOOTER ANIMATIONS ---
        function initFooterAnimations() {
            // Register ScrollTrigger
            gsap.registerPlugin(ScrollTrigger);

            const footer = document.querySelector('#advanced-footer');
            const ctaText = footer.querySelector('.footer-cta-section');
            const marquee = footer.querySelector('.footer-marquee');
            const gridCols = footer.querySelectorAll('.grid-col');

            // 1. Reveal CTA Section
            gsap.fromTo(ctaText,
                { y: 50, opacity: 0 },
                {
                    y: 0,
                    opacity: 1,
                    duration: 1,
                    ease: "power2.out",
                    scrollTrigger: {
                        trigger: footer,
                        start: "top 75%", // Triggers when top of footer hits 75% of viewport
                    }
                }
            );

            // 2. Expand Marquee width
            gsap.fromTo(marquee,
                { width: "0%", opacity: 0 },
                {
                    width: "100%",
                    opacity: 1,
                    duration: 1.2,
                    ease: "expo.out",
                    delay: 0.2,
                    scrollTrigger: {
                        trigger: footer,
                        start: "top 70%"
                    }
                }
            );

            // 3. Stagger Reveal Grid Columns
            gsap.fromTo(gridCols,
                { y: 30, opacity: 0 },
                {
                    y: 0,
                    opacity: 1,
                    duration: 0.8,
                    stagger: 0.1,
                    delay: 0.4,
                    scrollTrigger: {
                        trigger: footer,
                        start: "top 60%"
                    }
                }
            );
        }

        // Initialize when DOM is ready
        document.addEventListener("DOMContentLoaded", () => {
            initTypedSwap();
            initFooterAnimations();
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            gsap.registerPlugin(ScrollTrigger);

            const lenis = new Lenis();
            lenis.on("scroll", ScrollTrigger.update);
            gsap.ticker.add((time) => {
                lenis.raf(time * 1000);
            });
            gsap.ticker.lagSmoothing(0);

            // =========================================================
            // 1. SETUP AUDIO LOGIC
            // =========================================================
            const typeSound = new Audio('./assets/keyboard-typing-effect-free-393912.mp3');
            typeSound.loop = true; // Loops continuously while scrolling
            typeSound.volume = 0.5; // Adjust volume (0.0 to 1.0)

            let typeSoundTimeout;

            // Function to play sound only when moving
            function manageTypingSound(velocity) {
                // If scroll speed is significant (moving)
                if (Math.abs(velocity) > 5) {
                    if (typeSound.paused) {
                        typeSound.play().catch(e => { }); // Start playing
                    }

                    // Clear any timer that was about to stop the sound
                    clearTimeout(typeSoundTimeout);

                    // Set a new timer to stop sound if motion stops for 150ms
                    typeSoundTimeout = setTimeout(() => {
                        typeSound.pause();
                    }, 150);
                }
            }
            // =========================================================

            // Updated Selector
            const textBlocks = document.querySelectorAll(".kinetic-typography-block p");

            // Updated RGB value for the lighter background highlight (a slate blue tone)
            const wordHighlightRGB = "45, 59, 85";

            const specialKeywords = [
                "designed", "natural", "control", "ideas", "smooth",
                "performance", "creation", "attention", "value",
            ];

            textBlocks.forEach((paragraph) => {
                const textContent = paragraph.textContent;
                const splitWords = textContent.split(/\s+/);
                paragraph.innerHTML = "";

                splitWords.forEach((wordStr) => {
                    if (wordStr.trim()) {
                        const tokenContainer = document.createElement("div");
                        tokenContainer.className = "token-unit";

                        const innerSpan = document.createElement("span");
                        innerSpan.textContent = wordStr;

                        const cleanWord = wordStr.toLowerCase().replace(/[.,!?;:"]/g, "");

                        if (specialKeywords.includes(cleanWord)) {
                            tokenContainer.classList.add("highlight-anchor");
                            innerSpan.classList.add("emphasis-pill", cleanWord);
                        }

                        tokenContainer.appendChild(innerSpan);
                        paragraph.appendChild(tokenContainer);
                    }
                });
            });

            // Updated Selector
            const scrollHosts = document.querySelectorAll(".scroll-sequence-host");

            scrollHosts.forEach((hostEl) => {
                ScrollTrigger.create({
                    trigger: hostEl,
                    pin: hostEl,
                    start: "top top",
                    end: `+=${window.innerHeight * 4}`,
                    pinSpacing: true,
                    onUpdate: (self) => {

                        // --- TRIGGER AUDIO ---
                        manageTypingSound(self.getVelocity());
                        // ---------------------

                        const progress = self.progress;
                        // Updated Selector
                        const allTokens = Array.from(
                            hostEl.querySelectorAll(".kinetic-typography-block .token-unit")
                        );
                        const totalTokens = allTokens.length;

                        allTokens.forEach((token, idx) => {
                            const innerText = token.querySelector("span");

                            if (progress <= 0.7) {
                                // Reveal Phase
                                const progressTarget = 0.7;
                                const revealProgress = Math.min(1, progress / progressTarget);

                                const overlapCount = 15;
                                const animLength = 1 + overlapCount / totalTokens;

                                const startP = idx / totalTokens;
                                const endP = startP + overlapCount / totalTokens;

                                const timeScale = 1 / Math.min(
                                    animLength,
                                    1 + (totalTokens - 1) / totalTokens + overlapCount / totalTokens
                                );

                                const adjStart = startP * timeScale;
                                const adjEnd = endP * timeScale;
                                const duration = adjEnd - adjStart;

                                const tokenProgress = revealProgress <= adjStart
                                    ? 0
                                    : revealProgress >= adjEnd
                                        ? 1
                                        : (revealProgress - adjStart) / duration;

                                token.style.opacity = tokenProgress;

                                // Background Highlight Logic
                                const bgFadeStart = tokenProgress >= 0.9 ? (tokenProgress - 0.9) / 0.1 : 0;
                                const bgOpacity = Math.max(0, 1 - bgFadeStart);
                                token.style.backgroundColor = `rgba(${wordHighlightRGB}, ${bgOpacity})`;

                                // Text Opacity Logic
                                const textThreshold = 0.9;
                                const textRevealP = tokenProgress >= textThreshold
                                    ? (tokenProgress - textThreshold) / (1 - textThreshold)
                                    : 0;

                                innerText.style.opacity = Math.pow(textRevealP, 0.5);

                            } else {
                                // Exit Phase (Reverse/Fade)
                                const reverseProgress = (progress - 0.7) / 0.3;
                                token.style.opacity = 1;
                                const targetOpacity = 1;

                                const revOverlap = 5;
                                const revStart = idx / totalTokens;
                                const revEnd = revStart + revOverlap / totalTokens;

                                const revScale = 1 / Math.max(
                                    1,
                                    (totalTokens - 1) / totalTokens + revOverlap / totalTokens
                                );

                                const revAdjStart = revStart * revScale;
                                const revAdjEnd = revEnd * revScale;
                                const revDur = revAdjEnd - revAdjStart;

                                const revTokenP = reverseProgress <= revAdjStart
                                    ? 0
                                    : reverseProgress >= revAdjEnd
                                        ? 1
                                        : (reverseProgress - revAdjStart) / revDur;

                                if (revTokenP > 0) {
                                    innerText.style.opacity = targetOpacity * (1 - revTokenP);
                                    token.style.backgroundColor = `rgba(${wordHighlightRGB}, ${revTokenP})`;
                                } else {
                                    innerText.style.opacity = targetOpacity;
                                    token.style.backgroundColor = `rgba(${wordHighlightRGB}, 0)`;
                                }
                            }
                        });
                    },
                    // Stop sound immediately if we leave the section (scrolled past it)
                    onLeave: () => { typeSound.pause(); },
                    onLeaveBack: () => { typeSound.pause(); }
                });
            });
        });
    </script>
    <script>
        gsap.registerPlugin(ScrollTrigger);

        function initLoader() {
            const container = document.querySelector('.loader-screen');
            const loadingLetter = container.querySelectorAll('.willem__letter');
            const box = container.querySelectorAll('.willem-loader__box');
            const growingImage = container.querySelectorAll('.willem__growing-image');
            const headingStart = container.querySelectorAll('.willem__h1-start');
            const headingEnd = container.querySelectorAll('.willem__h1-end');
            const coverImageExtra = container.querySelectorAll('.willem__cover-image-extra');

            // 1. SETUP AUDIO
            const loaderSound = new Audio('./assets/loader.mp3');
            loaderSound.volume = 0.5;

            // --- MOBILE FIX: Unlock Audio Context on First Interaction ---
            // Mobile browsers block audio until the user interacts. 
            // This listener waits for the first touch/click anywhere to unlock the sound engine.
            const unlockAudio = () => {
                loaderSound.play().then(() => {
                    // Audio started successfully. 
                    // If the animation hasn't reached the sound point yet, we pause and reset.
                    // If it's already playing via the timeline, we let it continue.
                    if (loaderSound.currentTime > 0.1 && !loaderSound.paused) {
                        // It's already playing from the timeline, do nothing
                    } else {
                        loaderSound.pause();
                        loaderSound.currentTime = 0;
                    }
                }).catch((e) => {
                    // Still blocked (unlikely if triggered by touch), ignore
                });

                // Remove listeners so this only happens once
                document.removeEventListener('touchstart', unlockAudio);
                document.removeEventListener('click', unlockAudio);
            };

            // Listen for interaction immediately
            document.addEventListener('touchstart', unlockAudio, { once: true, passive: true });
            document.addEventListener('click', unlockAudio, { once: true });


            const tl = gsap.timeline({
                defaults: { ease: 'expo.inOut' },
                onComplete: () => {
                    document.body.classList.remove('is-loading');

                    // --- AUTOMATIC CLICK LOGIC ---
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;

                    // 1. Dispatch Mouse Events (Desktop)
                    const moveEvent = new MouseEvent('mousemove', {
                        view: window, bubbles: true, cancelable: true,
                        clientX: centerX, clientY: centerY
                    });
                    window.dispatchEvent(moveEvent);

                    const clickEvent = new MouseEvent('click', {
                        view: window, bubbles: true, cancelable: true,
                        clientX: centerX, clientY: centerY
                    });
                    window.dispatchEvent(clickEvent);

                    // 2. Dispatch Touch Events (Mobile Visuals Fix)
                    if (typeof TouchEvent !== 'undefined') {
                        try {
                            const touchObj = new Touch({
                                identifier: Date.now(),
                                target: window,
                                clientX: centerX, clientY: centerY,
                                radiusX: 2.5, radiusY: 2.5,
                                rotationAngle: 10, force: 0.5,
                            });

                            const touchStart = new TouchEvent('touchstart', {
                                cancelable: true, bubbles: true,
                                touches: [touchObj], targetTouches: [], changedTouches: [touchObj],
                                shiftKey: true,
                            });
                            window.dispatchEvent(touchStart);

                            const touchEnd = new TouchEvent('touchend', {
                                cancelable: true, bubbles: true,
                                touches: [], targetTouches: [], changedTouches: [touchObj],
                                shiftKey: true,
                            });
                            window.dispatchEvent(touchEnd);
                        } catch (e) {
                            console.warn("Touch event simulation failed (not supported on this browser).");
                        }
                    }

                    gsap.to(container, {
                        opacity: 0,
                        display: 'none',
                        duration: 0.5,
                        onComplete: () => ScrollTrigger.refresh()
                    });
                }
            });

            if (loadingLetter) { tl.from(loadingLetter, { yPercent: 100, stagger: 0.025, duration: 1.25 }); }
            if (box.length) { tl.fromTo(box, { width: '0em' }, { width: '1em', duration: 1.25 }, '< 1.25'); }
            if (growingImage.length) { tl.fromTo(growingImage, { width: '0%' }, { width: '100%', duration: 1.25 }, '<'); }
            if (headingStart.length) { tl.fromTo(headingStart, { x: '0em' }, { x: '-0.05em', duration: 1.25 }, '<'); }
            if (headingEnd.length) { tl.fromTo(headingEnd, { x: '0em' }, { x: '0.05em', duration: 1.25 }, '<'); }
            if (coverImageExtra.length) { tl.fromTo(coverImageExtra, { opacity: 1 }, { opacity: 0, duration: 0.05, ease: 'none', stagger: 0.5 }, '-=0.05'); }

            // --- 2. SYNCHRONIZED EXPANSION & SOUND ---
            tl.addLabel("zoomEffect", "< 1.25");

            if (growingImage.length) {
                tl.to(growingImage, { width: '100vw', height: '100vh', duration: 1.5 }, "zoomEffect");
            }

            if (box.length) {
                tl.to(box, { width: '100vw', duration: 1.5 }, "zoomEffect");
            }

            tl.call(() => {
                // Attempt to play. If on mobile and user hasn't touched yet, this catch block prevents error.
                loaderSound.play().catch(e => {
                    console.log("Audio waiting for user interaction.");
                });
            }, null, "zoomEffect+=0.4");
        } document.addEventListener('DOMContentLoaded', () => {
            initLoader();
            init3DMarker();
            initCarousel();
            initGlobalPageCursor();
            initFooterCursor();
            initFooterAnimations();
            initGlobalTextAnimations();
            initMobileHeadingEffect();
        });
        // --- GLOBAL PAGE CURSOR ANIMATION (NEW FUNCTION) ---
        function initGlobalPageCursor() {
            const globalCanvas = document.querySelector('#global-cursor-canvas');
            if (!globalCanvas) return;

            const globalCtx = globalCanvas.getContext('2d');
            let globalMouseMoved = false;

            const globalPointer = {
                x: 0.5 * window.innerWidth,
                y: 0.5 * window.innerHeight,
            };

            const params = {
                pointsNumber: 40,
                widthFactor: 0.3,
                mouseThreshold: 0.6,
                spring: 0.4,
                friction: 0.5,
            };

            const trail = new Array(params.pointsNumber);
            for (let i = 0; i < params.pointsNumber; i++) {
                trail[i] = {
                    x: globalPointer.x,
                    y: globalPointer.y,
                    dx: 0,
                    dy: 0,
                };
            }

            window.addEventListener('click', e => {
                updateGlobalMousePosition(e.clientX, e.clientY);
            });
            window.addEventListener('mousemove', e => {
                globalMouseMoved = true;
                updateGlobalMousePosition(e.clientX, e.clientY);
            });
            window.addEventListener('touchmove', e => {
                globalMouseMoved = true;
                updateGlobalMousePosition(e.targetTouches[0].clientX, e.targetTouches[0].clientY);
            });

            function updateGlobalMousePosition(eX, eY) {
                globalPointer.x = eX;
                globalPointer.y = eY;
            }

            function setupGlobalCanvas() {
                globalCanvas.width = window.innerWidth;
                globalCanvas.height = window.innerHeight;
            }

            function updateGlobal(t) {
                // Idle motion when mouse isn't moving
                if (!globalMouseMoved) {
                    globalPointer.x = (0.5 + 0.3 * Math.cos(0.002 * t) * Math.sin(0.005 * t)) * window.innerWidth;
                    globalPointer.y = (0.5 + 0.2 * Math.cos(0.005 * t) + 0.1 * Math.cos(0.01 * t)) * window.innerHeight;
                }

                globalCtx.clearRect(0, 0, globalCanvas.width, globalCanvas.height);

                trail.forEach((p, pIdx) => {
                    const prev = pIdx === 0 ? globalPointer : trail[pIdx - 1];
                    const spring = pIdx === 0 ? 0.4 * params.spring : params.spring;
                    p.dx += (prev.x - p.x) * spring;
                    p.dy += (prev.y - p.y) * spring;
                    p.dx *= params.friction;
                    p.dy *= params.friction;
                    p.x += p.dx;
                    p.y += p.dy;
                });

                globalCtx.lineCap = 'round';
                // Set color to white because we used mix-blend-mode: difference in CSS
                // This makes it look inverted on all backgrounds
                globalCtx.strokeStyle = '#ffffff';

                globalCtx.beginPath();
                globalCtx.moveTo(trail[0].x, trail[0].y);

                for (let i = 1; i < trail.length - 1; i++) {
                    const xc = 0.5 * (trail[i].x + trail[i + 1].x);
                    const yc = 0.5 * (trail[i].y + trail[i + 1].y);
                    globalCtx.quadraticCurveTo(trail[i].x, trail[i].y, xc, yc);
                    globalCtx.lineWidth = params.widthFactor * (params.pointsNumber - i);
                    globalCtx.stroke();
                }
                globalCtx.lineTo(trail[trail.length - 1].x, trail[trail.length - 1].y);
                globalCtx.stroke();

                window.requestAnimationFrame(updateGlobal);
            }

            window.addEventListener('resize', setupGlobalCanvas);

            // Initialize
            setupGlobalCanvas();
            updateGlobal(0);
        }

        // --- 1. URBANIST LOGIC ---
        const integrationSection = document.getElementById("urbanist-integration");
        const panes = gsap.utils.toArray(".pane");
        gsap.set(panes, { width: window.innerWidth });

        const themes = [
            { mainBg: "#b9dcff", subBg: "#f2fbfe", text: "#070f36", title: "#8dc9f4" },
            { mainBg: "#fff58c", subBg: "#fbf1ed", text: "#9c4e23", title: "#9c4e23" },
            { mainBg: "#c4ffb2", subBg: "#f1ffec", text: "#164c3b", title: "#164c3b" }
        ];

        const thresholds = new Array(panes.length).fill(0).map((_, i) => parseFloat(((1 / panes.length) * i).toFixed(2)));
        let activeThemeIndex = 0;

        gsap.to(panes, {
            xPercent: -100 * (panes.length - 1),
            ease: "none",
            scrollTrigger: {
                trigger: integrationSection,
                pin: true,
                scrub: 1,
                start: "top top",
                end: () => "+=" + (window.innerWidth * panes.length * 0.5),
                onUpdate: (self) => {
                    const progress = parseFloat(self.progress.toFixed(2));
                    const themeIndex = thresholds.findLastIndex((threshold) => progress >= threshold);
                    if (themeIndex !== activeThemeIndex && themeIndex >= 0) {
                        activeThemeIndex = themeIndex;
                        updateTheme(themeIndex);
                    }
                }
            }
        });

        function updateTheme(themeIndex) {
            const theme = themes[themeIndex];
            gsap.to(document.documentElement, {
                "--theme-main-bg": theme.mainBg,
                "--theme-sub-bg": theme.subBg,
                "--theme-title": theme.title,
                "--theme-text": theme.text,
                duration: 1,
                ease: "power2.out"
            });
        }

        // --- 2. PERSPECTIVE ZOOM LOGIC ---
        const zoomTimeline = gsap.timeline({
            scrollTrigger: {
                trigger: ".zoom-container",
                start: "top top",
                end: "+=200%",
                scrub: 1,
                pin: true
            }
        });
        zoomTimeline.to(".zoom-item[data-layer='3']", { z: 1000, opacity: 0, ease: "power1.in" }, 0);
        zoomTimeline.to(".zoom-item[data-layer='2']", { z: 600, opacity: 0, ease: "power1.in" }, 0.1);
        zoomTimeline.to(".zoom-item[data-layer='1']", { z: 300, opacity: 0, ease: "power1.in" }, 0.2);
        zoomTimeline.to(".heading-zoom", { z: 200, opacity: 1, scale: 1.5, ease: "power1.out" }, 0);

        // --- 3. TEXT REVEAL LOGIC ---
        const textElement = document.querySelector(".opacity-reveal");
        const textContent = textElement.innerText;
        textElement.innerHTML = '';
        textContent.split('').forEach(char => {
            const span = document.createElement('span');
            span.innerText = char;
            span.style.opacity = "0.1";
            textElement.appendChild(span);
        });
        const chars = textElement.querySelectorAll('span');
        const textTimeline = gsap.timeline({
            scrollTrigger: {
                trigger: ".section-stick",
                start: "center center",
                end: "+=150%",
                pin: true,
                scrub: 0.5
            }
        });
        textTimeline.to(chars, { opacity: 1, stagger: 0.02, duration: 1, ease: "none" })
            .to(textElement, { scale: 1.1, duration: 1, ease: "power2.out" }, "<");

        // --- 4. ALICE SECTION LOGIC ---
        const heroReveal = document.querySelectorAll(".hero-reveal");
        heroReveal.forEach((element) => {
            const heroBox = element.querySelector(".hero-reveal__header");
            const heroHeadings = element.querySelectorAll(".hero-reveal_split_item");
            const contentEl = element.querySelector(".hero-reveal__content");
            if (!heroBox || !contentEl) return;
            const heroBoxHeight = heroBox.offsetHeight;
            const contentHeight = contentEl.offsetHeight;
            const pinDistance = heroBoxHeight > contentHeight ? heroBoxHeight : contentHeight;

            gsap.fromTo(contentEl, { y: "50%" }, {
                y: "0%", ease: "none",
                scrollTrigger: { trigger: element, start: "top top", end: `+=${pinDistance}`, scrub: true }
            });

            const tl = gsap.timeline({ scrollTrigger: { trigger: element, start: "top top", end: `+=${pinDistance}`, scrub: true, pin: true } });
            tl.fromTo(heroBox, { clipPath: "inset(0% 0% 0% 0%)" }, { clipPath: "inset(0% 0% 100% 0%)", duration: 1, ease: "power1.inOut" });

            if (heroHeadings.length >= 2) {
                tl.fromTo(heroHeadings[0], { y: "0%" }, { y: "-30%", ease: "power1.inOut" }, 0);
                tl.fromTo(heroHeadings[1], { y: "0%" }, { y: "30%", ease: "power1.inOut" }, 0);
            }
        });

        function parallaxScrollBySpeed(selector, speed = 1, trigger = ".hero-reveal") {
            const el = document.querySelector(selector);
            const contentEl = document.querySelector(".hero-reveal__content");
            if (!el || !contentEl) return;
            const contentHeight = contentEl.offsetHeight;
            gsap.to(el, {
                yPercent: (speed - 1) * 100, ease: "none",
                scrollTrigger: { trigger: trigger, start: "top top", end: `+=${contentHeight * 2}`, scrub: true }
            });
        }
        parallaxScrollBySpeed(".hero-reveal__parallax-book", 15);
        parallaxScrollBySpeed(".hero-reveal__parallax-clock", 13);
        parallaxScrollBySpeed(".hero-reveal__parallax-alice", 6);
        parallaxScrollBySpeed(".hero-reveal__parallax-kattle", 23);
        parallaxScrollBySpeed(".hero-reveal__parallax-card", 5);

        // --- 5. CAROUSEL SECTION LOGIC (FIXED & STABLE) ---
        function initCarousel() {
            const carouselSection = document.querySelector("#carousel-section");
            const slides = gsap.utils.toArray(".slide"); // Get all pre-rendered slides

            // Create a timeline that spans the pinning duration
            const tl = gsap.timeline({
                scrollTrigger: {
                    trigger: carouselSection,
                    start: "top top",
                    end: "+=4000",
                    scrub: 1, // Smooth scrubbing, user can reverse easily
                    pin: true
                }
            });
            // 1. Reveal Slide 2
            tl.to("#slide-2", {
                clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                duration: 1,
                ease: "none" // Linear ease for direct mapping to scroll
            });

            // 2. Reveal Slide 3
            tl.to("#slide-3", {
                clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                duration: 1,
                ease: "none"
            });

            // 3. Reveal Slide 4
            tl.to("#slide-4", {
                clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                duration: 1,
                ease: "none"
            });

            // Add a small buffer at the end so the user sees the last slide before unpinning
            tl.to({}, { duration: 0.5 });
        }

        // --- 6. FOOTER CURSOR LOGIC ---
        function initFooterCursor() {
            const canvas = document.querySelector('#footer-canvas');
            const footer = document.querySelector('#advanced-footer');
            if (!canvas || !footer) return;

            const ctx = canvas.getContext('2d');
            let mouseMoved = false;

            const pointer = { x: 0.5 * window.innerWidth, y: 0.5 * window.innerHeight };
            const params = {
                pointsNumber: 40,
                widthFactor: 0.3,
                mouseThreshold: 0.6,
                spring: 0.4,
                friction: 0.5,
            };

            const trail = new Array(params.pointsNumber);
            for (let i = 0; i < params.pointsNumber; i++) {
                trail[i] = { x: pointer.x, y: pointer.y, dx: 0, dy: 0 };
            }

            footer.addEventListener('mousemove', e => {
                mouseMoved = true;
                const rect = footer.getBoundingClientRect();
                pointer.x = e.clientX - rect.left;
                pointer.y = e.clientY - rect.top;
            });

            // Also handle global window resizing
            window.addEventListener('resize', setupCanvas);

            function setupCanvas() {
                const rect = footer.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
            }

            function update(t) {
                // If mouse hasn't moved yet, create a gentle idle animation
                if (!mouseMoved) {
                    pointer.x = (0.5 + 0.3 * Math.cos(0.002 * t) * Math.sin(0.005 * t)) * canvas.width;
                    pointer.y = (0.5 + 0.2 * Math.cos(0.005 * t) + 0.1 * Math.cos(0.01 * t)) * canvas.height;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                trail.forEach((p, pIdx) => {
                    const prev = pIdx === 0 ? pointer : trail[pIdx - 1];
                    const spring = pIdx === 0 ? 0.4 * params.spring : params.spring;
                    p.dx += (prev.x - p.x) * spring;
                    p.dy += (prev.y - p.y) * spring;
                    p.dx *= params.friction;
                    p.dy *= params.friction;
                    p.x += p.dx;
                    p.y += p.dy;
                });

                ctx.lineCap = 'round';
                ctx.strokeStyle = '#ffffff'; // White trail on black footer
                ctx.beginPath();
                ctx.moveTo(trail[0].x, trail[0].y);

                for (let i = 1; i < trail.length - 1; i++) {
                    const xc = 0.5 * (trail[i].x + trail[i + 1].x);
                    const yc = 0.5 * (trail[i].y + trail[i + 1].y);
                    ctx.quadraticCurveTo(trail[i].x, trail[i].y, xc, yc);
                    ctx.lineWidth = params.widthFactor * (params.pointsNumber - i);
                    ctx.stroke();
                }
                ctx.lineTo(trail[trail.length - 1].x, trail[trail.length - 1].y);
                ctx.stroke();

                window.requestAnimationFrame(update);
            }

            setupCanvas();
            update(0);
        }

        // --- 7. FOOTER REVEAL ANIMATIONS ---
        function initFooterAnimations() {
            const footer = document.querySelector('#advanced-footer');
            const bigText = footer.querySelector('.footer-big-text');
            const links = footer.querySelectorAll('.footer-links a');
            const bottom = footer.querySelector('.footer-bottom');

            // Animate Big Text
            gsap.to(bigText, {
                opacity: 1,
                y: 0,
                duration: 1.5,
                ease: "power3.out",
                scrollTrigger: {
                    trigger: footer,
                    start: "top 75%",
                }
            });

            // Animate Links Stagger
            gsap.to(links, {
                y: 0,
                duration: 1,
                stagger: 0.1,
                ease: "power3.out",
                scrollTrigger: {
                    trigger: footer,
                    start: "top 75%",
                }
            });

            // Animate Bottom Bar
            gsap.to(bottom, {
                opacity: 1,
                duration: 1,
                delay: 0.5,
                scrollTrigger: {
                    trigger: footer,
                    start: "top 80%",
                }
            });
        }
    </script>
    <script>function init3DMarker() {
            const container = document.getElementById('threejs-marker-container');
            if (!container) return;

            // --- 1. SETUP THREE.JS SCENE ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 28;

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 10, 20);
            dirLight.castShadow = true;
            scene.add(dirLight);
            const spotLight = new THREE.SpotLight(0xffffff, 0.8);
            spotLight.position.set(-10, 0, 10);
            scene.add(spotLight);

            // --- 2. BUILD THE MARKER ---
            // Materials
            function createLabelTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 1024; canvas.height = 512;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#fcfcfc'; ctx.fillRect(0, 0, 1024, 512);
                ctx.fillStyle = '#000000'; ctx.font = '900 130px Helvetica, Arial'; ctx.textAlign = 'center'; ctx.fillText('WHITE BOARD', 512, 250);
                ctx.fillStyle = '#d91c24'; ctx.fillRect(720, 170, 250, 90);
                ctx.fillStyle = '#ffffff'; ctx.font = 'bold 60px Helvetica, Arial'; ctx.fillText('Camlin', 845, 235);
                return new THREE.CanvasTexture(canvas);
            }
            const labelTex = createLabelTexture();
            labelTex.wrapS = THREE.RepeatWrapping; labelTex.repeat.set(-1, 1); labelTex.offset.set(0.75, 0);

            const matBody = new THREE.MeshStandardMaterial({ map: labelTex, roughness: 0.3, metalness: 0.05 });
            const matRed = new THREE.MeshStandardMaterial({ color: 0xd91c24, roughness: 0.2, metalness: 0.1 });
            const matNib = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
            const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });

            // Groups: markerSystem (GSAP moves this) -> floatGroup (Math moves this) -> body/cap
            const markerSystem = new THREE.Group();
            scene.add(markerSystem);
            const floatGroup = new THREE.Group();
            markerSystem.add(floatGroup);

            const r = 0.8; const len = 8.0;

            // Body
            const bodyGroup = new THREE.Group();
            floatGroup.add(bodyGroup);
            const cyl = new THREE.Mesh(new THREE.CylinderGeometry(r, r, len, 64), matBody);
            cyl.rotation.y = Math.PI; cyl.castShadow = true; bodyGroup.add(cyl);
            const plug = new THREE.Mesh(new THREE.CylinderGeometry(r, r, 0.5, 64), matRed);
            plug.position.y = (len / 2) + 0.25; bodyGroup.add(plug);
            const taper = new THREE.Mesh(new THREE.CylinderGeometry(r, 0.45, 1.8, 64), matWhite);
            taper.position.y = -(len / 2) - 0.9; bodyGroup.add(taper);
            // Replaced sharp Cone with blunt Cylinder for smoother look
            const nib = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.3, 0.9, 32), matNib);
            nib.position.y = -(len / 2) - 2.1; nib.rotation.z = Math.PI; bodyGroup.add(nib);

            // Cap
            const capGroup = new THREE.Group();
            floatGroup.add(capGroup);
            const capLen = 3.8; const capR = r + 0.12;
            const capShell = new THREE.Mesh(new THREE.CylinderGeometry(capR - 0.05, capR, capLen, 64), matRed);
            capShell.geometry.translate(0, -capLen / 2, 0); capShell.castShadow = true; capGroup.add(capShell);
            const ring = new THREE.Mesh(new THREE.CylinderGeometry(capR + 0.1, capR + 0.1, 0.6, 64), matRed);
            ring.position.y = -0.5; capGroup.add(ring);
            const clip = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2.8, 0.5), matRed);
            clip.position.set(capR + 0.05, -2.0, 0); capGroup.add(clip);

            // Initial Layout
            const bodyStartY = 12.0; const capStartY = -14.0;
            const bodyClosedY = 0; const capClosedY = -3.9;
            bodyGroup.position.y = bodyStartY; capGroup.position.y = capStartY;

            // --- 3. ANIMATION CONFIGURATION ---
            // This is where you define the "Dance" for each section
            const isMobile = window.innerWidth < 768;

            const sectionStates = [
                {
                    // STATE 0: HERO (Initial)
                    // Cap Closing Animation happens here separately
                    trigger: ".hero",
                    start: "top top", end: "bottom top",
                    desktop: { x: 6.5, y: 2, z: 0, rotX: 0, rotY: 0, rotZ: -0.78, scale: 1 },
                    mobile: { x: 2.0, y: 1.5, z: 0, rotX: 0, rotY: 0, rotZ: -0.78, scale: 0.4 }
                },
                {
                    // STATE 1: URBANIST (Move to Left Side, Rotate 90 deg)
                    trigger: "#urbanist-integration",
                    start: "top bottom", end: "center center",
                    desktop: { x: -9, y: 0, z: 0, rotX: 0.2, rotY: Math.PI, rotZ: Math.PI - 0.5, scale: 0.9 },
                    mobile: { x: -2, y: -4, z: 0, rotX: 0.2, rotY: Math.PI, rotZ: Math.PI - 0.5, scale: 0.35 }
                },
                {
                    // STATE 2: GRID SCROLL (Move Top Right, Horizontal)
                    trigger: "#grid-scroll-wrapper",
                    start: "top bottom", end: "center center",
                    desktop: { x: 8, y: 4, z: -2, rotX: 0, rotY: Math.PI * 2, rotZ: -1.57, scale: 0.8 },
                    mobile: { x: 2, y: 5, z: -2, rotX: 0, rotY: Math.PI * 2, rotZ: -1.57, scale: 0.35 }
                },
                {
                    // STATE 3: ALICE SECTION (Move Bottom Left, Diagonal Flip)
                    trigger: "#alice-wrapper",
                    start: "top bottom", end: "center center",
                    desktop: { x: -8, y: -3, z: 2, rotX: 0.5, rotY: Math.PI * 3, rotZ: Math.PI - 0.7, scale: 0.9 },
                    mobile: { x: -2, y: -2, z: 2, rotX: 0.5, rotY: Math.PI * 3, rotZ: Math.PI - 0.7, scale: 0.35 }
                },
                {
                    // STATE 4: TEXT/CAPABILITIES (Center Right, Vertical)
                    trigger: ".capabilities-segment",
                    start: "top bottom", end: "center center",
                    desktop: { x: 9, y: 0, z: 0, rotX: 0, rotY: Math.PI * 3.5, rotZ: Math.PI, scale: 0.9 },
                    mobile: { x: 2.5, y: 0, z: 0, rotX: 0, rotY: Math.PI * 3.5, rotZ: Math.PI, scale: 0.35 }
                }
            ];

            // --- 4. APPLY INITIAL POSITION ---
            const startState = isMobile ? sectionStates[0].mobile : sectionStates[0].desktop;
            markerSystem.position.set(startState.x, startState.y, startState.z);
            markerSystem.rotation.set(startState.rotX, startState.rotY, startState.rotZ);
            markerSystem.scale.set(startState.scale, startState.scale, startState.scale);


            // --- 5. CREATE SCROLL TRIGGERS ---

            // 1. SETUP AUDIO (Add this new part)
            const capSound = new Audio('./assets/closeSound.mpeg');
            capSound.volume = 0.6; // Adjust volume if needed

            // A. SPECIAL HERO CAP ANIMATION (Closing the marker)
            const heroTl = gsap.timeline({
                scrollTrigger: {
                    trigger: ".hero",
                    start: "top top",
                    end: "80% top",
                    scrub: 1,
                    // NEW: Play sound when scrolling down finishes the "closing" action
                    onLeave: () => {
                        capSound.currentTime = 0; // Reset sound to start
                        capSound.play().catch(e => console.log("Audio waiting for interaction"));
                    },
                    // Optional: If you want it to click again if they scroll up and then back down
                    onEnterBack: () => {
                        // Resets logic if needed, but usually sound only plays on close
                    }
                }
            });

            // ... (Rest of your existing code: heroTl.to bodyGroup, capGroup etc) ...
            heroTl.to(bodyGroup.position, { y: bodyClosedY, ease: "power2.out" }, 0);
            heroTl.to(capGroup.position, { y: capClosedY, ease: "power2.out" }, 0);


            // B. MOVEMENT ANIMATIONS (Connecting Sections)
            // We skip index 0 because that's our starting point
            for (let i = 1; i < sectionStates.length; i++) {
                const prevState = sectionStates[i - 1];
                const currState = sectionStates[i];

                const prevCfg = isMobile ? prevState.mobile : prevState.desktop;
                const currCfg = isMobile ? currState.mobile : currState.desktop;

                // Create a timeline for this section's transition
                const tl = gsap.timeline({
                    scrollTrigger: {
                        trigger: currState.trigger,
                        start: currState.start,
                        end: currState.end,
                        scrub: isMobile ? 1 : 1.5, // Faster scrub for mobile responsiveness
                    }
                });

                // Position
                tl.fromTo(markerSystem.position,
                    { x: prevCfg.x, y: prevCfg.y, z: prevCfg.z },
                    { x: currCfg.x, y: currCfg.y, z: currCfg.z, ease: "power1.inOut", immediateRender: false },
                    0
                );

                // Rotation
                tl.fromTo(markerSystem.rotation,
                    { x: prevCfg.rotX, y: prevCfg.rotY, z: prevCfg.rotZ },
                    { x: currCfg.rotX, y: currCfg.rotY, z: currCfg.rotZ, ease: "power1.inOut", immediateRender: false },
                    0
                );

                // Scale
                tl.fromTo(markerSystem.scale,
                    { x: prevCfg.scale, y: prevCfg.scale, z: prevCfg.scale },
                    { x: currCfg.scale, y: currCfg.scale, z: currCfg.scale, ease: "power1.inOut", immediateRender: false },
                    0
                );
            }


            // C. HIDE MARKER AT PRIME INK SECTION
            gsap.to(container, {
                opacity: 0,
                duration: 0.5,
                ease: "power2.inOut",
                scrollTrigger: {
                    trigger: ".hero-reveal",
                    start: "top center",
                    toggleActions: "play none none reverse"
                }
            });


            // --- 6. RENDER LOOP (With Floating Motion) ---
            function animate() {
                requestAnimationFrame(animate);
                const t = Date.now() * 0.001;

                // Independent Idle Animation (Sine Waves)
                // This happens on TOP of the GSAP scrolling movement
                floatGroup.position.y = Math.sin(t * 1.5) * 0.3; // Bob up/down
                floatGroup.rotation.x = Math.sin(t * 1.2) * 0.1; // Gentle tilt
                floatGroup.rotation.z = Math.cos(t * 0.9) * 0.1; // Gentle sway

                renderer.render(scene, camera);
            }
            animate();


            // --- 7. RESIZE HANDLER ---
            function onResize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
                // Note: We don't reset positions here to avoid conflict with ScrollTrigger
                // A full refresh is better for responsive layout changes
            }
            window.addEventListener('resize', onResize);
        }</script>
    <script>
        function initGlobalTextAnimations() {
            const textElements = document.querySelectorAll("h1, h2, h3, h4, p, li, span.footer-big-text");

            textElements.forEach((element) => {
                if (element.closest('.loader-screen')) return;
                if (element.closest('.hero__title')) return;
                if (element.closest('.kinetic-typography-block')) return;
                if (element.closest('#panes-container')) return;

                gsap.fromTo(element,
                    {
                        y: 50,
                        opacity: 0,
                        clipPath: "polygon(0 0, 100% 0, 100% 0, 0 0)"
                    },
                    {
                        y: 0,
                        opacity: 1,
                        clipPath: "polygon(0 0, 100% 0, 100% 100%, 0 100%)",
                        duration: 1,
                        ease: "power3.out",
                        scrollTrigger: {
                            trigger: element,
                            start: "top 90%",
                            toggleActions: "play none none reverse"
                        }
                    }
                );
            });
        }
    </script>
    <script>
        function initMobileHeadingEffect() {
            ScrollTrigger.matchMedia({

                // Target Mobile Screens (max-width 768px)
                "(max-width: 768px)": function () {

                    gsap.to(".intro__heading", {
                        y: 420,
                        opacity: 1,
                        ease: "none",
                        scrollTrigger: {
                            trigger: ".intro",
                            start: "top 40%",
                            end: "bottom top",
                            scrub: 1
                        }
                    });

                }
            });
        }
    </script>
    <script>
        const canvas = document.getElementById("hero-canvas");
        const ctx = canvas.getContext("2d");
        let lastPos = null;

        // --- FIX 1: Allow default touch actions so users can scroll ---
        canvas.style.touchAction = "auto";

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + "px";
            canvas.style.height = window.innerHeight + "px";
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
            ctx.globalCompositeOperation = "source-over";
            ctx.fillStyle = "#fff";
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
            ctx.globalCompositeOperation = "destination-out";
            ctx.lineCap = "round";
            ctx.lineWidth = 70;
            ctx.strokeStyle = "rgba(0,0,0,1)";
        }

        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);
        window.addEventListener("load", resizeCanvas);
        setTimeout(resizeCanvas, 500);

        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function draw(e) {
            // --- FIX 2: Removed e.preventDefault() so page can scroll ---
            // If you want to disable scratching ONLY on mobile to make scrolling easier,
            // you can uncomment this line:
            // if (window.innerWidth < 768) return; 

            const { x, y } = getCoords(e);
            ctx.beginPath();
            if (lastPos) {
                ctx.moveTo(lastPos.x, lastPos.y);
                ctx.lineTo(x, y);
                ctx.stroke();
            }
            lastPos = { x, y };
        }

        function handleStart(e) {
            // --- FIX 3: Removed e.preventDefault() here too ---
            const { x, y } = getCoords(e);
            lastPos = { x, y };
        }

        function handleEnd() {
            lastPos = null;
        }

        // Mouse Events
        canvas.addEventListener("mousemove", draw);
        canvas.addEventListener("mouseleave", handleEnd);

        // Touch Events
        // --- FIX 4: Changed passive to true (allows scrolling while touching) ---
        canvas.addEventListener("touchstart", handleStart, { passive: true });
        canvas.addEventListener("touchmove", draw, { passive: true });
        canvas.addEventListener("touchend", handleEnd);

        // --- Custom Cursor Logic (Kept unchanged) ---
        const cursor = document.querySelector(".custom-cursor");
        if (cursor) { // Added safety check
            const interactiveSelector = ["a[href]", "button", "canvas", '[role="button"]', "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", '[data-cursor="interactive"]'].join(",");
            const stickyItems = document.querySelectorAll(".sticky-item");
            let isSticky = false;

            function isPureBlack(e) { if (!e || !e.startsWith("rgb")) return !1; const [t, s, o] = e.match(/\d+/g).map(Number); return t === 0 && s === 0 && o === 0 }
            function isBackgroundBlack(e) { for (; e && e !== document.body;) { const t = getComputedStyle(e).backgroundColor; if (t !== "rgba(0, 0, 0, 0)" && !isPureBlack(t)) return !1; e = e.parentElement } return !0 }
            function getAllElementsAt(e, t) { const s = [], o = []; let l; for (; (l = document.elementFromPoint(e, t)) && !s.includes(l);)s.push(l), o.push({ el: l, pe: l.style.pointerEvents }), l.style.pointerEvents = "none"; return o.forEach(({ el: n, pe: a }) => n.style.pointerEvents = a), s }

            let rAF = null;
            function handlePointerMove(e) { rAF || (rAF = requestAnimationFrame(() => { isSticky || (cursor.style.transform = `translate(${e.clientX}px, ${e.clientY}px) translate(-50%, -50%)`); const s = getAllElementsAt(e.clientX, e.clientY).every(isBackgroundBlack); cursor.classList.toggle("red", s); const o = document.elementFromPoint(e.clientX, e.clientY), l = o && o.closest(interactiveSelector); cursor.classList.toggle("--interactive", !!l), rAF = null })) }
            document.addEventListener("mousemove", handlePointerMove);
            stickyItems.forEach(e => { e.addEventListener("mouseenter", () => { const t = e.getBoundingClientRect(), s = t.left + t.width / 2, o = t.top + t.height / 2; cursor.classList.add("--sticky"), cursor.style.transform = `translate(${s}px, ${o}px) translate(-50%, -50%)`, isSticky = !0 }), e.addEventListener("mouseleave", () => { cursor.classList.remove("--sticky"), isSticky = !1 }) });
            document.addEventListener("mouseleave", () => cursor.style.opacity = "0");
            document.addEventListener("mouseenter", () => cursor.style.opacity = "1");
        }
    </script>
    <script>
        // ULTIMATE ROBUST ANIMATION SCRIPT
        // Injected inline to guarantee execution
        document.addEventListener("DOMContentLoaded", () => {
            console.log("Initializing Inline Card Animations...");
            const targets = [".intro-viewport", ".action-trigger-zone", ".conclusion-viewport"];

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    // Trigger if any part is visible
                    if (entry.isIntersecting) {
                        animateEntry(entry.target);
                        observer.unobserve(entry.target);
                    }
                });
            }, { threshold: 0.1 }); // Low threshold to ensure it catches

            function animateEntry(section) {
                if (section.dataset.animating === "true") return;
                section.dataset.animating = "true";

                const card = section.querySelector('.content-wrapper');
                const heading = card ? section.querySelector('h1') : null;

                if (!card || !heading) return;

                // Ensure visibility (in case it was hidden)
                card.style.opacity = '1';
                // But we want to animate from 0 if possible. 
                // Let's use GSAP if available, otherwise fallback.

                if (typeof gsap !== 'undefined') {
                    // Reset for animation: Start VERY small (almost a dot)
                    gsap.set(card, {
                        scale: 0.05,        // Very small size
                        opacity: 0,
                        y: 80,
                        borderRadius: "50%", // Fully rounded to look like a dot/circle
                        filter: "blur(10px)"
                    });

                    // Split text if needed
                    if (!heading.querySelector('.char')) {
                        const text = heading.innerText;
                        heading.innerHTML = '';
                        text.split("").forEach(char => {
                            const s = document.createElement('span');
                            s.className = 'char';
                            s.innerHTML = char === ' ' ? '&nbsp;' : char;
                            s.style.display = 'inline-block';
                            heading.appendChild(s);
                        });
                    }
                    const chars = heading.querySelectorAll('.char');
                    gsap.set(chars, { y: 30, opacity: 0, filter: "blur(8px)" });

                    const tl = gsap.timeline();

                    // Card Animation: Smooth expansion from dot to card
                    tl.to(card, {
                        duration: 1.4,
                        scale: 1,
                        opacity: 1,
                        y: 0,
                        borderRadius: "32px", // Transition to card radius
                        filter: "blur(0px)",
                        ease: "power4.out"    // Very smooth deceleration
                    })
                        // Text Animation: Elegant fade-up
                        .to(chars, {
                            duration: 1,
                            y: 0,
                            opacity: 1,
                            filter: "blur(0px)",
                            stagger: 0.02,
                            ease: "power2.out"
                        }, "-=1.0"); // Start slightly earlier during card expansion
                } else {
                    // CSS Fallback if GSAP missing
                    card.style.transition = "transform 1s, opacity 1s";
                    card.style.transform = "scale(1) translateY(0)";
                    card.style.opacity = "1";
                }
            }

            targets.forEach(sel => {
                const el = document.querySelector(sel);
                if (el) observer.observe(el);
            });

            // FAILSAFE: Force visible after 3 seconds
            setTimeout(() => {
                targets.forEach(sel => {
                    const el = document.querySelector(sel);
                    if (el && !el.dataset.animating) {
                        const card = el.querySelector('.content-wrapper');
                        if (card) card.style.opacity = 1;
                    }
                });
            }, 3000);
        });
    </script>
</body>

</html>