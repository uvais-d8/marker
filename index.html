<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARKER</title>
    <!-- Fonts -->
    <link rel="preload" href="./assets/fonts/Presicav.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="./assets/fonts/Calibre-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="./assets/fonts/Arial.woff2" as="font" type="font/woff2" crossorigin="anonymous">

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://api.fontshare.com/v2/css?f[]=neue-montreal@500&display=swap" rel="stylesheet">

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    <script src="https://unpkg.com/lenis@1.1.20/dist/lenis.min.js"></script>
    <script type="module" crossorigin src="./js/index.min.js?v=1754734869502"></script>
    <link rel="stylesheet" crossorigin href="./css/index.min.css?v=1754734869502">
    <link rel="stylesheet" href="./style.css">

</head>

<body class="is-loading">

    <canvas id="global-cursor-canvas"></canvas>

    <div id="threejs-marker-container"></div>
    <section class="loader-screen">
        <div class="loader-content">
            <div class="willem__h1">
                <div class="willem__h1-start">
                    <span class="willem__letter">M</span>
                    <span class="willem__letter">A</span>
                    <span class="willem__letter">R</span>
                </div>
                <div class="willem-loader__box">
                    <div class="willem-loader__box-inner">
                        <div class="willem__growing-image">
                            <div class="willem__growing-image-wrap">
                                <img class="willem__cover-image-extra is--1" src="./assets/marker1.jpg" loading="lazy"
                                    alt="">
                                <img class="willem__cover-image-extra is--2" src="./assets/marker2.jpeg" loading="lazy"
                                    alt="">
                                <img class="willem__cover-image-extra is--3" src="./assets/marker3.webp" loading="lazy"
                                    alt="">
                                <img class="willem__cover-image" src='./assets/white.png' loading="lazy" alt="">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="willem__h1-end">
                    <span class="willem__letter">K</span>
                    <span class="willem__letter">E</span>
                    <span class="willem__letter">R</span>
                </div>
            </div>
        </div>
    </section>

    <div class="wrapper">
        <header class="header fade" data-fls-header="" data-fls-header-scroll="" data-fls-header-scroll-show="">
            <div class="header__container">
                <div class="header__menu menu">
                    <h1 class="logo">
                        <a href="#">MARKER</a>
                    </h1>
                </div>
            </div>
        </header>

        <main class="page page--home">

            <section class="hero">
                <video class="hero__video" src="./files/banner-hero.mov" autoplay muted loop playsinline=""></video>
                <canvas class="hero__canvas" id="hero-canvas"></canvas>
                <h1 class="hero__title" data-fls-watcher="" data-fls-watcher-once="">
                    <span>MARKER</span>
                </h1>
            </section>
            <section id="urbanist-integration">
                <svg class="urbanist-bg" width="100%" viewBox="0 0 1920 1300" fill="none"
                    xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none">
                    <rect width="1920" height="1300" fill="url(#gradient)"></rect>
                    <defs>
                        <linearGradient id="gradient" x1="1300.54" y1="201.621" x2="959.727" y2="841.863"
                            gradientUnits="userSpaceOnUse">
                            <stop offset="0.15" stop-color="var(--theme-sub-bg)" stop-opacity="1"></stop>
                            <stop offset="0.85" stop-color="var(--theme-main-bg)"></stop>
                        </linearGradient>
                    </defs>
                </svg>

                <div class="content-layer">
                    <h1>Marker</h1>
                    <p class="desc-1">
                        The Marker font captures the spontaneous energy and look of a broad-tipped permanent
                        marker, offering a bold and authentic hand-drawn aesthetic for digital interfaces.
                    </p>
                    <p class="desc-2">
                        Characterized by its irregular edges, organic flow, and varying stroke weights, it
                        breaks away from rigid digital grids to deliver a raw, human touch.
                    </p>
                    <p class="desc-3">
                        Ideal for impactful headlines and creative overlays, this typeface transforms
                        standard typography into expressive, attention-grabbing visual statements.
                    </p>
                </div>

                <div id="panes-container">
                    <div class="pane">
                        <img class="urbanist-floating-img" src="./assets/blue.png" alt="Marker design inspiration 1">
                    </div>
                    <div class="pane">
                        <img class="urbanist-floating-img" src="./assets/orange.png" alt="Marker design inspiration 2">
                    </div>
                    <div class="pane">
                        <img class="urbanist-floating-img" src="./assets/green.png" alt="Marker design inspiration 3">
                    </div>
                </div>
            </section>
            <section id="grid-scroll-wrapper">
                <section style="margin-bottom: -200px;" class="section-stick">
                    <p class="opacity-reveal reveal-text-style">
                        If you’re bold, a single marker stroke will break the grid, steal the show, and change
                        everything.
                    </p>
                </section>
            </section>
            <div id="alice-wrapper">
                <section class="intro">
                    <h1 class="intro__heading">Marker Colour Priority and Visual Hierarchy</h1>
                </section>
                <section class="content">
                    <article class="article">
                        <h4 style="margin-top: 20px;color: red;"><b>Red Marker (Highest Priority)</b></h4>
                        <p>
                            RED is the most attention-grabbing marker colour. It represents urgency,
                            <b>danger</b>, and high
                            <b>importance</b>,
                            making it ideal for warnings and critical highlights.
                        </p>
                        <p class="mobile-hidden">
                            Its strong visual impact ensures immediate focus, so it is used carefully and with clear
                            intention.
                        </p>

                        <h4 style="margin-top: 20px;color: black;"><b>Black Marker</b></h4>
                        <p>
                            BLACK symbolizes clarity and authority. It is widely used for writing, outlining, and
                            clear
                            <b>communication</b> due to its high readability .
                        </p>
                        <p class="mobile-hidden">
                            Because of its professional appearance, black is preferred for formal and final work.
                        </p>

                        <h4 style="margin-top: 20px;color: blue;"><b>Blue Marker</b></h4>
                        <p>
                            BLUE represents trust and <b>calmness</b>. It is commonly used for general writing
                            and explanations
                            without creating visual stress.
                        </p>
                        <p class="mobile-hidden">
                            This colour is suitable for notes and planning where balance and clarity are needed.
                        </p>

                        <h4 style="margin-top: 20px;color: green;"><b>Green Marker (Lowest Priority)</b></h4>
                        <p>
                            GREEN stands for positivity and <b>approval</b>. It is often used to show
                            <b>correctness</b> or progress.
                        </p>
                        <p class="mobile-hidden">
                            With lower urgency, green works best for supportive and secondary highlights.
                        </p>
                    </article>
                </section>
                <div class="hero-reveal-wrapper">
                    <section class="hero-reveal">
                        <article>
                            <header class="hero-reveal__header">
                                <div class="hero-reveal_split">
                                    <div class="hero-reveal_split_item">
                                        <p>PRIME INK</p>
                                    </div>
                                    <div class="hero-reveal_split_item" aria-hidden="true">
                                        <p aria-hidden="true">PRIME INK</p>
                                    </div>
                                </div>
                            </header>

                            <div class="hero-reveal__content">
                                <div class="hero-reveal__content-inner">
                                    <div class="hero-reveal__parallax">
                                        <img src="https://assets.codepen.io/204808/alice-falling-1.png" alt="Alice"
                                            class="hero-reveal__parallax-alice" />
                                        <img width="150" src="https://assets.codepen.io/204808/alice-falling-clock.png"
                                            alt="Clock" class="hero-reveal__parallax-clock" />
                                        <img width="100" src="https://assets.codepen.io/204808/alice-falling-book.png"
                                            alt="Book" class="hero-reveal__parallax-book" />
                                        <img width="50" src="https://assets.codepen.io/204808/alice-falling-kattle.png"
                                            alt="Kattle" class="hero-reveal__parallax-kattle" />
                                        <img width="330" src="https://assets.codepen.io/204808/alice-falling-card.png"
                                            alt="Card" class="hero-reveal__parallax-card" />
                                    </div>

                                    <div class="hero-reveal__content-p">
                                        <p>
                                            <B>The ink of the marker</B> flowed with confidence, bold and consistent,
                                            leaving
                                            behind a stroke that felt
                                            <B>permanent and intentional</B>. It dried quickly on the surface, resisting
                                            smudges, while the pigment
                                            settled deep into the material, giving the line its strong and lasting
                                            presence.
                                        </p>
                                        <p class="mobile-hidden">
                                            As the marker moved, the ink revealed its character — rich in color,
                                            balanced in density, and smooth
                                            in motion. Each stroke carried clarity, allowing ideas to take shape without
                                            interruption or loss
                                            of control.
                                        </p>
                                        <p>
                                            Unlike ordinary pens, marker ink is designed to command attention. Its
                                            formulation blends pigments
                                            and solvents carefully, ensuring even coverage while maintaining durability
                                            across different
                                            surfaces and textures.
                                        </p>
                                        <p class="mobile-hidden">
                                            <B>“This is not just ink,”</B> the creator realized, <B>“it is expression
                                                itself.”</B>
                                            With every line drawn, the
                                            marker transformed thought into form, leaving marks that spoke with
                                            strength, precision, and purpose.
                                        </p>
                                    </div>

                                </div>
                            </div>
                        </article>
                    </section>
                </div>
                <section style="background-color: white;" class="content">

                </section>
            </div>
            <section class="viewport-section intro-viewport">
                <div class="content-wrapper">
                    <h1>A creative marker built for clarity, control, and expression.</h1>
                </div>
            </section>
            <section class="viewport-section narrative-segment scroll-sequence-host">
                <div class="content-wrapper">
                    <div class="kinetic-typography-block">
                        <p>
                            Marker is designed as a focused tool for creators who value precision
                            and intention. Every stroke carries meaning, and every interaction is
                            crafted to feel natural, responsive, and purposeful.
                        </p>
                        <p>
                            More than a simple tool, Marker adapts to your workflow. It gives you
                            control over form, movement, and structure while staying effortless
                            to use. From quick ideas to refined details, Marker supports the way
                            you think and create.
                        </p>
                    </div>
                </div>
            </section>
            <section class="viewport-section action-trigger-zone">
                <div class="content-wrapper">
                    <h1>Create with confidence using Marker’s powerful tools.</h1>
                </div>
            </section>
            <section class="viewport-section capabilities-segment scroll-sequence-host">
                <div class="content-wrapper">
                    <div class="kinetic-typography-block">
                        <p>
                            Marker offers smooth interactions, adaptive precision, and intelligent
                            responsiveness in every feature. Whether you are highlighting ideas,
                            shaping concepts, or guiding attention, Marker reacts instantly and
                            accurately to your intent.
                        </p>
                        <p>
                            With optimized performance, flexible controls, and real-time feedback,
                            Marker transforms simple actions into expressive outcomes. It is built
                            to stay out of your way while enhancing every moment of creation.
                        </p>
                    </div>
                </div>
            </section>
            <section class="viewport-section conclusion-viewport">
                <div class="content-wrapper">
                    <h1>Marker empowers creators to define ideas with purpose.</h1>
                </div>
            </section>


            <footer id="advanced-footer">

                <div class="footer-container">

                    <div class="footer-cta-section">
                        <div class="cta-text-wrapper">
                            <span class="cta-label">Have an idea?</span>
                            <h2 class="cta-big-text" data-fls-typed="duration:0.6; stagger:0.04;">
                                DEFINING CLARITY THROUGH INK</h2>
                        </div>
                        <a href="#contact" class="magnetic-button  mobile-hidden">
                            <div class="btn-fill"></div>
                            <span class="btn-text">Get in Touch</span>
                            <span class="btn-icon">↗</span>
                        </a>
                    </div>

                    <div class="footer-marquee">
                        <div class="track">
                            <div class="content">
                                MARKER DIGITAL — PRECISION TOOLS — MARKER DIGITAL — PRECISION TOOLS — MARKER DIGITAL —
                                PRECISION TOOLS —
                                MARKER DIGITAL — PRECISION TOOLS — MARKER DIGITAL — PRECISION TOOLS — MARKER DIGITAL —
                                PRECISION TOOLS —
                            </div>
                        </div>
                    </div>

                    <div class="footer-grid">
                        <div class="grid-col brand-col">
                            <div class="footer-lamp-wrapper">
                                <div class="lamp">
                                    <div class="line"></div>
                                    <div class="base">
                                        <div class="light"></div>
                                    </div>
                                </div>
                                <div class="lamp-text">
                                    <span style="margin-top: 70px;color: rgb(87, 87, 87);">MARKER</span>
                                </div>
                            </div>
                            <p style="margin-top: 1rem; opacity: 0.5;">Est. 2025</p>
                        </div>
                        <div class="grid-col links-col">
                            <h4>Socials</h4>
                            <ul>
                                <li><a href="#" class="hover-link">Instagram</a></li>
                                <li><a href="#" class="hover-link">LinkedIn</a></li>
                                <li><a href="#" class="hover-link">Twitter / X</a></li>
                                <li><a href="#" class="hover-link">Behance</a></li>
                            </ul>
                        </div>

                        <div class="grid-col newsletter-col">
                            <h4>Stay Updated</h4>
                            <form class="newsletter-form">
                                <input type="email" placeholder="Email address" required>
                                <button type="submit">→</button>
                            </form>
                        </div>
                    </div>

                    <div class="footer-bottom">
                        <div class="meta-left">
                            <span>© 2025 Marker Digital.</span>
                        </div>
                        <div class="meta-right">
                            <a href="#" class="scroll-top-btn"
                                onclick="window.scrollTo({top: 0, behavior: 'smooth'}); return false;">
                                Back to Top ↑
                            </a>
                        </div>
                    </div>
                </div>
            </footer>

        </main>
    </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

<script>
document.addEventListener("DOMContentLoaded", () => {
    gsap.registerPlugin(ScrollTrigger);

    const targets = [".intro-viewport", ".action-trigger-zone", ".conclusion-viewport"];

    targets.forEach(selector => {
        const section = document.querySelector(selector);
        if (!section) return;

        const card = section.querySelector('.content-wrapper');
        const heading = card.querySelector('h1');

        // 1. Split Text
        const text = heading.innerText;
        heading.innerHTML = text.split("").map(char => 
            char === " " ? `<span style="display:inline-block; width: 0.3em;">&nbsp;</span>` : `<span class="char">${char}</span>`
        ).join("");

        // 2. The Timeline
        const tl = gsap.timeline({
            scrollTrigger: {
                trigger: section,
                start: "top 75%",
                end: "bottom 25%",
                toggleActions: "play none none reverse"
            }
        });

        // 3. The "Smooth" Expansion
        tl.fromTo(card, 
            { 
                scale: 0.2,       // Starts very tiny
                opacity: 0,
                y: 50,            // Starts slightly lower
                borderRadius: "10rem" // Starts very rounded
            },
            {
                duration: 1.8,    // Longer duration for smoothness
                scale: 1,
                opacity: 1,
                y: 0,
                borderRadius: "2rem",
                ease: "expo.out", // The "Luxury" curve: Fast start, slow finish
                clearProps: "all"
            }
        )
        // 4. Smooth Text Fade-in with Blur
        .fromTo(heading.querySelectorAll(".char"), 
            {
                y: 20,
                opacity: 0,
                filter: "blur(10px)" // Starts blurry
            },
            {
                duration: 1,
                y: 0,
                opacity: 1,
                filter: "blur(0px)", // Becomes clear
                stagger: 0.02,
                ease: "power2.out"
            }, "-=1.4"); // Start early while card is still expanding
    });
});
</script>
    <script>
        // --- 1. TYPED SWAP EFFECT LOGIC ---
        function initTypedSwap() {
            const ATTR = 'data-fls-typed';

            // Helper to split text correctly
            const splitChars = str => {
                return [...str]; // Simple spread for modern browsers
            };

            const parseOpts = root => {
                const def = { duration: 0.45, stagger: 0.03, ease: 'power2.out' };
                const raw = root.getAttribute(ATTR);
                if (raw) {
                    raw.split(';').forEach(p => {
                        const [k, v] = p.split(':').map(s => s.trim());
                        if (k === 'duration') def.duration = parseFloat(v);
                        if (k === 'stagger') def.stagger = parseFloat(v);
                    });
                }
                return def;
            };

            document.querySelectorAll(`[${ATTR}]`).forEach(root => {
                const text = root.textContent.trim();
                root.textContent = '';
                const opt = parseOpts(root);

                // Create Base (Normal) and Alt (Italic/Stroke) layers
                const base = document.createElement('span');
                base.className = 'tsw__base';
                const alt = document.createElement('span');
                alt.className = 'tsw__alt';

                // Inject characters
                splitChars(text).forEach((char, i) => {
                    const s1 = document.createElement('span');
                    s1.className = 'char';
                    s1.textContent = char === ' ' ? '\u00A0' : char;
                    s1.style.transitionDelay = `${i * opt.stagger}s`;

                    const s2 = s1.cloneNode(true);

                    base.appendChild(s1);
                    alt.appendChild(s2);
                });

                root.appendChild(base);
                root.appendChild(alt);
            });
        }

        // --- 2. GSAP FOOTER ANIMATIONS ---
        function initFooterAnimations() {
            // Register ScrollTrigger
            gsap.registerPlugin(ScrollTrigger);

            const footer = document.querySelector('#advanced-footer');
            const ctaText = footer.querySelector('.footer-cta-section');
            const marquee = footer.querySelector('.footer-marquee');
            const gridCols = footer.querySelectorAll('.grid-col');

            // 1. Reveal CTA Section
            gsap.fromTo(ctaText,
                { y: 50, opacity: 0 },
                {
                    y: 0,
                    opacity: 1,
                    duration: 1,
                    ease: "power2.out",
                    scrollTrigger: {
                        trigger: footer,
                        start: "top 75%", // Triggers when top of footer hits 75% of viewport
                    }
                }
            );

            // 2. Expand Marquee width
            gsap.fromTo(marquee,
                { width: "0%", opacity: 0 },
                {
                    width: "100%",
                    opacity: 1,
                    duration: 1.2,
                    ease: "expo.out",
                    delay: 0.2,
                    scrollTrigger: {
                        trigger: footer,
                        start: "top 70%"
                    }
                }
            );

            // 3. Stagger Reveal Grid Columns
            gsap.fromTo(gridCols,
                { y: 30, opacity: 0 },
                {
                    y: 0,
                    opacity: 1,
                    duration: 0.8,
                    stagger: 0.1,
                    delay: 0.4,
                    scrollTrigger: {
                        trigger: footer,
                        start: "top 60%"
                    }
                }
            );
        }

        // Initialize when DOM is ready
        document.addEventListener("DOMContentLoaded", () => {
            initTypedSwap();
            initFooterAnimations();
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            gsap.registerPlugin(ScrollTrigger);

            const lenis = new Lenis();
            lenis.on("scroll", ScrollTrigger.update);
            gsap.ticker.add((time) => {
                lenis.raf(time * 1000);
            });
            gsap.ticker.lagSmoothing(0);

            // Updated Selector
            const textBlocks = document.querySelectorAll(".kinetic-typography-block p");

            // Updated RGB value for the lighter background highlight (a slate blue tone)
            const wordHighlightRGB = "45, 59, 85";

            const specialKeywords = [
                "designed",
                "natural",
                "control",
                "ideas",
                "smooth",
                "performance",
                "creation",
                "attention",
                "value",
            ];

            textBlocks.forEach((paragraph) => {
                const textContent = paragraph.textContent;
                const splitWords = textContent.split(/\s+/);
                paragraph.innerHTML = "";

                splitWords.forEach((wordStr) => {
                    if (wordStr.trim()) {
                        const tokenContainer = document.createElement("div");
                        // Updated Class Name
                        tokenContainer.className = "token-unit";

                        const innerSpan = document.createElement("span");
                        innerSpan.textContent = wordStr;

                        const cleanWord = wordStr.toLowerCase().replace(/[.,!?;:"]/g, "");

                        if (specialKeywords.includes(cleanWord)) {
                            // Updated Class Names
                            tokenContainer.classList.add("highlight-anchor");
                            innerSpan.classList.add("emphasis-pill", cleanWord);
                        }

                        tokenContainer.appendChild(innerSpan);
                        paragraph.appendChild(tokenContainer);
                    }
                });
            });

            // Updated Selector
            const scrollHosts = document.querySelectorAll(".scroll-sequence-host");

            scrollHosts.forEach((hostEl) => {
                ScrollTrigger.create({
                    trigger: hostEl,
                    pin: hostEl,
                    start: "top top",
                    end: `+=${window.innerHeight * 4}`,
                    pinSpacing: true,
                    onUpdate: (self) => {
                        const progress = self.progress;
                        // Updated Selector
                        const allTokens = Array.from(
                            hostEl.querySelectorAll(".kinetic-typography-block .token-unit")
                        );
                        const totalTokens = allTokens.length;

                        allTokens.forEach((token, idx) => {
                            const innerText = token.querySelector("span");

                            if (progress <= 0.7) {
                                // Reveal Phase
                                const progressTarget = 0.7;
                                const revealProgress = Math.min(1, progress / progressTarget);

                                const overlapCount = 15;
                                const animLength = 1 + overlapCount / totalTokens;

                                const startP = idx / totalTokens;
                                const endP = startP + overlapCount / totalTokens;

                                const timeScale = 1 / Math.min(
                                    animLength,
                                    1 + (totalTokens - 1) / totalTokens + overlapCount / totalTokens
                                );

                                const adjStart = startP * timeScale;
                                const adjEnd = endP * timeScale;
                                const duration = adjEnd - adjStart;

                                const tokenProgress = revealProgress <= adjStart
                                    ? 0
                                    : revealProgress >= adjEnd
                                        ? 1
                                        : (revealProgress - adjStart) / duration;

                                token.style.opacity = tokenProgress;

                                // Background Highlight Logic
                                const bgFadeStart = tokenProgress >= 0.9 ? (tokenProgress - 0.9) / 0.1 : 0;
                                const bgOpacity = Math.max(0, 1 - bgFadeStart);
                                token.style.backgroundColor = `rgba(${wordHighlightRGB}, ${bgOpacity})`;

                                // Text Opacity Logic
                                const textThreshold = 0.9;
                                const textRevealP = tokenProgress >= textThreshold
                                    ? (tokenProgress - textThreshold) / (1 - textThreshold)
                                    : 0;

                                innerText.style.opacity = Math.pow(textRevealP, 0.5);

                            } else {
                                // Exit Phase (Reverse/Fade)
                                const reverseProgress = (progress - 0.7) / 0.3;
                                token.style.opacity = 1;
                                const targetOpacity = 1;

                                const revOverlap = 5;
                                const revStart = idx / totalTokens;
                                const revEnd = revStart + revOverlap / totalTokens;

                                const revScale = 1 / Math.max(
                                    1,
                                    (totalTokens - 1) / totalTokens + revOverlap / totalTokens
                                );

                                const revAdjStart = revStart * revScale;
                                const revAdjEnd = revEnd * revScale;
                                const revDur = revAdjEnd - revAdjStart;

                                const revTokenP = reverseProgress <= revAdjStart
                                    ? 0
                                    : reverseProgress >= revAdjEnd
                                        ? 1
                                        : (reverseProgress - revAdjStart) / revDur;

                                if (revTokenP > 0) {
                                    innerText.style.opacity = targetOpacity * (1 - revTokenP);
                                    token.style.backgroundColor = `rgba(${wordHighlightRGB}, ${revTokenP})`;
                                } else {
                                    innerText.style.opacity = targetOpacity;
                                    token.style.backgroundColor = `rgba(${wordHighlightRGB}, 0)`;
                                }
                            }
                        });
                    },
                });
            });
        });
    </script>
    <script>
        gsap.registerPlugin(ScrollTrigger);

        // --- 0. LOADER ANIMATION (OSMO/WILLEM) ---
        function initLoader() {
            const container = document.querySelector('.loader-screen');
            const loadingLetter = container.querySelectorAll('.willem__letter');
            const box = container.querySelectorAll('.willem-loader__box');
            const growingImage = container.querySelectorAll('.willem__growing-image');
            const headingStart = container.querySelectorAll('.willem__h1-start');
            const headingEnd = container.querySelectorAll('.willem__h1-end');
            const coverImageExtra = container.querySelectorAll('.willem__cover-image-extra');

            const tl = gsap.timeline({
                defaults: { ease: 'expo.inOut' },
                onComplete: () => {
                    document.body.classList.remove('is-loading');
                    gsap.to(container, {
                        opacity: 0,
                        display: 'none',
                        duration: 0.5,
                        onComplete: () => ScrollTrigger.refresh()
                    });
                }
            });

            if (loadingLetter) { tl.from(loadingLetter, { yPercent: 100, stagger: 0.025, duration: 1.25 }); }
            if (box.length) { tl.fromTo(box, { width: '0em' }, { width: '1em', duration: 1.25 }, '< 1.25'); }
            if (growingImage.length) { tl.fromTo(growingImage, { width: '0%' }, { width: '100%', duration: 1.25 }, '<'); }
            if (headingStart.length) { tl.fromTo(headingStart, { x: '0em' }, { x: '-0.05em', duration: 1.25 }, '<'); }
            if (headingEnd.length) { tl.fromTo(headingEnd, { x: '0em' }, { x: '0.05em', duration: 1.25 }, '<'); }
            if (coverImageExtra.length) { tl.fromTo(coverImageExtra, { opacity: 1 }, { opacity: 0, duration: 0.05, ease: 'none', stagger: 0.5 }, '-=0.05'); }
            if (growingImage.length) { tl.to(growingImage, { width: '100vw', height: '100vh', duration: 1.5 }, '< 1.25'); }
            if (box.length) { tl.to(box, { width: '100vw', duration: 1.5 }, '<'); }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initLoader();
            initCarousel();
            initGlobalPageCursor();
            initFooterCursor();
            initFooterAnimations();
            init3DMarker();
            initGlobalTextAnimations();
            initMobileHeadingEffect();
        });

        // --- GLOBAL PAGE CURSOR ANIMATION (NEW FUNCTION) ---
        function initGlobalPageCursor() {
            const globalCanvas = document.querySelector('#global-cursor-canvas');
            if (!globalCanvas) return;

            const globalCtx = globalCanvas.getContext('2d');
            let globalMouseMoved = false;

            const globalPointer = {
                x: 0.5 * window.innerWidth,
                y: 0.5 * window.innerHeight,
            };

            const params = {
                pointsNumber: 40,
                widthFactor: 0.3,
                mouseThreshold: 0.6,
                spring: 0.4,
                friction: 0.5,
            };

            const trail = new Array(params.pointsNumber);
            for (let i = 0; i < params.pointsNumber; i++) {
                trail[i] = {
                    x: globalPointer.x,
                    y: globalPointer.y,
                    dx: 0,
                    dy: 0,
                };
            }

            window.addEventListener('click', e => {
                updateGlobalMousePosition(e.clientX, e.clientY);
            });
            window.addEventListener('mousemove', e => {
                globalMouseMoved = true;
                updateGlobalMousePosition(e.clientX, e.clientY);
            });
            window.addEventListener('touchmove', e => {
                globalMouseMoved = true;
                updateGlobalMousePosition(e.targetTouches[0].clientX, e.targetTouches[0].clientY);
            });

            function updateGlobalMousePosition(eX, eY) {
                globalPointer.x = eX;
                globalPointer.y = eY;
            }

            function setupGlobalCanvas() {
                globalCanvas.width = window.innerWidth;
                globalCanvas.height = window.innerHeight;
            }

            function updateGlobal(t) {
                // Idle motion when mouse isn't moving
                if (!globalMouseMoved) {
                    globalPointer.x = (0.5 + 0.3 * Math.cos(0.002 * t) * Math.sin(0.005 * t)) * window.innerWidth;
                    globalPointer.y = (0.5 + 0.2 * Math.cos(0.005 * t) + 0.1 * Math.cos(0.01 * t)) * window.innerHeight;
                }

                globalCtx.clearRect(0, 0, globalCanvas.width, globalCanvas.height);

                trail.forEach((p, pIdx) => {
                    const prev = pIdx === 0 ? globalPointer : trail[pIdx - 1];
                    const spring = pIdx === 0 ? 0.4 * params.spring : params.spring;
                    p.dx += (prev.x - p.x) * spring;
                    p.dy += (prev.y - p.y) * spring;
                    p.dx *= params.friction;
                    p.dy *= params.friction;
                    p.x += p.dx;
                    p.y += p.dy;
                });

                globalCtx.lineCap = 'round';
                // Set color to white because we used mix-blend-mode: difference in CSS
                // This makes it look inverted on all backgrounds
                globalCtx.strokeStyle = '#ffffff';

                globalCtx.beginPath();
                globalCtx.moveTo(trail[0].x, trail[0].y);

                for (let i = 1; i < trail.length - 1; i++) {
                    const xc = 0.5 * (trail[i].x + trail[i + 1].x);
                    const yc = 0.5 * (trail[i].y + trail[i + 1].y);
                    globalCtx.quadraticCurveTo(trail[i].x, trail[i].y, xc, yc);
                    globalCtx.lineWidth = params.widthFactor * (params.pointsNumber - i);
                    globalCtx.stroke();
                }
                globalCtx.lineTo(trail[trail.length - 1].x, trail[trail.length - 1].y);
                globalCtx.stroke();

                window.requestAnimationFrame(updateGlobal);
            }

            window.addEventListener('resize', setupGlobalCanvas);

            // Initialize
            setupGlobalCanvas();
            updateGlobal(0);
        }

        // --- 1. URBANIST LOGIC ---
        const integrationSection = document.getElementById("urbanist-integration");
        const panes = gsap.utils.toArray(".pane");
        gsap.set(panes, { width: window.innerWidth });

        const themes = [
            { mainBg: "#b9dcff", subBg: "#f2fbfe", text: "#070f36", title: "#8dc9f4" },
            { mainBg: "#fff58c", subBg: "#fbf1ed", text: "#9c4e23", title: "#9c4e23" },
            { mainBg: "#c4ffb2", subBg: "#f1ffec", text: "#164c3b", title: "#164c3b" }
        ];

        const thresholds = new Array(panes.length).fill(0).map((_, i) => parseFloat(((1 / panes.length) * i).toFixed(2)));
        let activeThemeIndex = 0;

        gsap.to(panes, {
            xPercent: -100 * (panes.length - 1),
            ease: "none",
            scrollTrigger: {
                trigger: integrationSection,
                pin: true,
                scrub: 1,
                start: "top top",
                end: () => "+=" + (window.innerWidth * panes.length * 0.5),
                onUpdate: (self) => {
                    const progress = parseFloat(self.progress.toFixed(2));
                    const themeIndex = thresholds.findLastIndex((threshold) => progress >= threshold);
                    if (themeIndex !== activeThemeIndex && themeIndex >= 0) {
                        activeThemeIndex = themeIndex;
                        updateTheme(themeIndex);
                    }
                }
            }
        });

        function updateTheme(themeIndex) {
            const theme = themes[themeIndex];
            gsap.to(document.documentElement, {
                "--theme-main-bg": theme.mainBg,
                "--theme-sub-bg": theme.subBg,
                "--theme-title": theme.title,
                "--theme-text": theme.text,
                duration: 1,
                ease: "power2.out"
            });
        }

        // --- 2. PERSPECTIVE ZOOM LOGIC ---
        const zoomTimeline = gsap.timeline({
            scrollTrigger: {
                trigger: ".zoom-container",
                start: "top top",
                end: "+=200%",
                scrub: 1,
                pin: true
            }
        });
        zoomTimeline.to(".zoom-item[data-layer='3']", { z: 1000, opacity: 0, ease: "power1.in" }, 0);
        zoomTimeline.to(".zoom-item[data-layer='2']", { z: 600, opacity: 0, ease: "power1.in" }, 0.1);
        zoomTimeline.to(".zoom-item[data-layer='1']", { z: 300, opacity: 0, ease: "power1.in" }, 0.2);
        zoomTimeline.to(".heading-zoom", { z: 200, opacity: 1, scale: 1.5, ease: "power1.out" }, 0);

        // --- 3. TEXT REVEAL LOGIC ---
        const textElement = document.querySelector(".opacity-reveal");
        const textContent = textElement.innerText;
        textElement.innerHTML = '';
        textContent.split('').forEach(char => {
            const span = document.createElement('span');
            span.innerText = char;
            span.style.opacity = "0.1";
            textElement.appendChild(span);
        });
        const chars = textElement.querySelectorAll('span');
        const textTimeline = gsap.timeline({
            scrollTrigger: {
                trigger: ".section-stick",
                start: "center center",
                end: "+=150%",
                pin: true,
                scrub: 0.5
            }
        });
        textTimeline.to(chars, { opacity: 1, stagger: 0.02, duration: 1, ease: "none" })
            .to(textElement, { scale: 1.1, duration: 1, ease: "power2.out" }, "<");

        // --- 4. ALICE SECTION LOGIC ---
        const heroReveal = document.querySelectorAll(".hero-reveal");
        heroReveal.forEach((element) => {
            const heroBox = element.querySelector(".hero-reveal__header");
            const heroHeadings = element.querySelectorAll(".hero-reveal_split_item");
            const contentEl = element.querySelector(".hero-reveal__content");
            if (!heroBox || !contentEl) return;
            const heroBoxHeight = heroBox.offsetHeight;
            const contentHeight = contentEl.offsetHeight;
            const pinDistance = heroBoxHeight > contentHeight ? heroBoxHeight : contentHeight;

            gsap.fromTo(contentEl, { y: "50%" }, {
                y: "0%", ease: "none",
                scrollTrigger: { trigger: element, start: "top top", end: `+=${pinDistance}`, scrub: true }
            });

            const tl = gsap.timeline({ scrollTrigger: { trigger: element, start: "top top", end: `+=${pinDistance}`, scrub: true, pin: true } });
            tl.fromTo(heroBox, { clipPath: "inset(0% 0% 0% 0%)" }, { clipPath: "inset(0% 0% 100% 0%)", duration: 1, ease: "power1.inOut" });

            if (heroHeadings.length >= 2) {
                tl.fromTo(heroHeadings[0], { y: "0%" }, { y: "-30%", ease: "power1.inOut" }, 0);
                tl.fromTo(heroHeadings[1], { y: "0%" }, { y: "30%", ease: "power1.inOut" }, 0);
            }
        });

        function parallaxScrollBySpeed(selector, speed = 1, trigger = ".hero-reveal") {
            const el = document.querySelector(selector);
            const contentEl = document.querySelector(".hero-reveal__content");
            if (!el || !contentEl) return;
            const contentHeight = contentEl.offsetHeight;
            gsap.to(el, {
                yPercent: (speed - 1) * 100, ease: "none",
                scrollTrigger: { trigger: trigger, start: "top top", end: `+=${contentHeight * 2}`, scrub: true }
            });
        }
        parallaxScrollBySpeed(".hero-reveal__parallax-book", 15);
        parallaxScrollBySpeed(".hero-reveal__parallax-clock", 13);
        parallaxScrollBySpeed(".hero-reveal__parallax-alice", 6);
        parallaxScrollBySpeed(".hero-reveal__parallax-kattle", 23);
        parallaxScrollBySpeed(".hero-reveal__parallax-card", 5);

        // --- 5. CAROUSEL SECTION LOGIC (FIXED & STABLE) ---
        function initCarousel() {
            const carouselSection = document.querySelector("#carousel-section");
            const slides = gsap.utils.toArray(".slide"); // Get all pre-rendered slides

            // Create a timeline that spans the pinning duration
            const tl = gsap.timeline({
                scrollTrigger: {
                    trigger: carouselSection,
                    start: "top top",
                    end: "+=4000",
                    scrub: 1, // Smooth scrubbing, user can reverse easily
                    pin: true
                }
            });
            // 1. Reveal Slide 2
            tl.to("#slide-2", {
                clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                duration: 1,
                ease: "none" // Linear ease for direct mapping to scroll
            });

            // 2. Reveal Slide 3
            tl.to("#slide-3", {
                clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                duration: 1,
                ease: "none"
            });

            // 3. Reveal Slide 4
            tl.to("#slide-4", {
                clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                duration: 1,
                ease: "none"
            });

            // Add a small buffer at the end so the user sees the last slide before unpinning
            tl.to({}, { duration: 0.5 });
        }

        // --- 6. FOOTER CURSOR LOGIC ---
        function initFooterCursor() {
            const canvas = document.querySelector('#footer-canvas');
            const footer = document.querySelector('#advanced-footer');
            if (!canvas || !footer) return;

            const ctx = canvas.getContext('2d');
            let mouseMoved = false;

            const pointer = { x: 0.5 * window.innerWidth, y: 0.5 * window.innerHeight };
            const params = {
                pointsNumber: 40,
                widthFactor: 0.3,
                mouseThreshold: 0.6,
                spring: 0.4,
                friction: 0.5,
            };

            const trail = new Array(params.pointsNumber);
            for (let i = 0; i < params.pointsNumber; i++) {
                trail[i] = { x: pointer.x, y: pointer.y, dx: 0, dy: 0 };
            }

            footer.addEventListener('mousemove', e => {
                mouseMoved = true;
                const rect = footer.getBoundingClientRect();
                pointer.x = e.clientX - rect.left;
                pointer.y = e.clientY - rect.top;
            });

            // Also handle global window resizing
            window.addEventListener('resize', setupCanvas);

            function setupCanvas() {
                const rect = footer.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
            }

            function update(t) {
                // If mouse hasn't moved yet, create a gentle idle animation
                if (!mouseMoved) {
                    pointer.x = (0.5 + 0.3 * Math.cos(0.002 * t) * Math.sin(0.005 * t)) * canvas.width;
                    pointer.y = (0.5 + 0.2 * Math.cos(0.005 * t) + 0.1 * Math.cos(0.01 * t)) * canvas.height;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                trail.forEach((p, pIdx) => {
                    const prev = pIdx === 0 ? pointer : trail[pIdx - 1];
                    const spring = pIdx === 0 ? 0.4 * params.spring : params.spring;
                    p.dx += (prev.x - p.x) * spring;
                    p.dy += (prev.y - p.y) * spring;
                    p.dx *= params.friction;
                    p.dy *= params.friction;
                    p.x += p.dx;
                    p.y += p.dy;
                });

                ctx.lineCap = 'round';
                ctx.strokeStyle = '#ffffff'; // White trail on black footer
                ctx.beginPath();
                ctx.moveTo(trail[0].x, trail[0].y);

                for (let i = 1; i < trail.length - 1; i++) {
                    const xc = 0.5 * (trail[i].x + trail[i + 1].x);
                    const yc = 0.5 * (trail[i].y + trail[i + 1].y);
                    ctx.quadraticCurveTo(trail[i].x, trail[i].y, xc, yc);
                    ctx.lineWidth = params.widthFactor * (params.pointsNumber - i);
                    ctx.stroke();
                }
                ctx.lineTo(trail[trail.length - 1].x, trail[trail.length - 1].y);
                ctx.stroke();

                window.requestAnimationFrame(update);
            }

            setupCanvas();
            update(0);
        }

        // --- 7. FOOTER REVEAL ANIMATIONS ---
        function initFooterAnimations() {
            const footer = document.querySelector('#advanced-footer');
            const bigText = footer.querySelector('.footer-big-text');
            const links = footer.querySelectorAll('.footer-links a');
            const bottom = footer.querySelector('.footer-bottom');

            // Animate Big Text
            gsap.to(bigText, {
                opacity: 1,
                y: 0,
                duration: 1.5,
                ease: "power3.out",
                scrollTrigger: {
                    trigger: footer,
                    start: "top 75%",
                }
            });

            // Animate Links Stagger
            gsap.to(links, {
                y: 0,
                duration: 1,
                stagger: 0.1,
                ease: "power3.out",
                scrollTrigger: {
                    trigger: footer,
                    start: "top 75%",
                }
            });

            // Animate Bottom Bar
            gsap.to(bottom, {
                opacity: 1,
                duration: 1,
                delay: 0.5,
                scrollTrigger: {
                    trigger: footer,
                    start: "top 80%",
                }
            });
        }
    </script>
    <script>function init3DMarker() {
            const container = document.getElementById('threejs-marker-container');
            if (!container) return;

            // --- 1. SETUP THREE.JS SCENE ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 28;

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 10, 20);
            dirLight.castShadow = true;
            scene.add(dirLight);
            const spotLight = new THREE.SpotLight(0xffffff, 0.8);
            spotLight.position.set(-10, 0, 10);
            scene.add(spotLight);

            // --- 2. BUILD THE MARKER ---
            // Materials
            function createLabelTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 1024; canvas.height = 512;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#fcfcfc'; ctx.fillRect(0, 0, 1024, 512);
                ctx.fillStyle = '#000000'; ctx.font = '900 130px Helvetica, Arial'; ctx.textAlign = 'center'; ctx.fillText('WHITE BOARD', 512, 250);
                ctx.fillStyle = '#d91c24'; ctx.fillRect(720, 170, 250, 90);
                ctx.fillStyle = '#ffffff'; ctx.font = 'bold 60px Helvetica, Arial'; ctx.fillText('Camlin', 845, 235);
                return new THREE.CanvasTexture(canvas);
            }
            const labelTex = createLabelTexture();
            labelTex.wrapS = THREE.RepeatWrapping; labelTex.repeat.set(-1, 1); labelTex.offset.set(0.75, 0);

            const matBody = new THREE.MeshStandardMaterial({ map: labelTex, roughness: 0.3, metalness: 0.05 });
            const matRed = new THREE.MeshStandardMaterial({ color: 0xd91c24, roughness: 0.2, metalness: 0.1 });
            const matNib = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
            const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });

            // Groups: markerSystem (GSAP moves this) -> floatGroup (Math moves this) -> body/cap
            const markerSystem = new THREE.Group();
            scene.add(markerSystem);
            const floatGroup = new THREE.Group();
            markerSystem.add(floatGroup);

            const r = 0.8; const len = 8.0;

            // Body
            const bodyGroup = new THREE.Group();
            floatGroup.add(bodyGroup);
            const cyl = new THREE.Mesh(new THREE.CylinderGeometry(r, r, len, 64), matBody);
            cyl.rotation.y = Math.PI; cyl.castShadow = true; bodyGroup.add(cyl);
            const plug = new THREE.Mesh(new THREE.CylinderGeometry(r, r, 0.5, 64), matRed);
            plug.position.y = (len / 2) + 0.25; bodyGroup.add(plug);
            const taper = new THREE.Mesh(new THREE.CylinderGeometry(r, 0.45, 1.8, 64), matWhite);
            taper.position.y = -(len / 2) - 0.9; bodyGroup.add(taper);
            // Replaced sharp Cone with blunt Cylinder for smoother look
            const nib = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.3, 0.9, 32), matNib);
            nib.position.y = -(len / 2) - 2.1; nib.rotation.z = Math.PI; bodyGroup.add(nib);

            // Cap
            const capGroup = new THREE.Group();
            floatGroup.add(capGroup);
            const capLen = 3.8; const capR = r + 0.12;
            const capShell = new THREE.Mesh(new THREE.CylinderGeometry(capR - 0.05, capR, capLen, 64), matRed);
            capShell.geometry.translate(0, -capLen / 2, 0); capShell.castShadow = true; capGroup.add(capShell);
            const ring = new THREE.Mesh(new THREE.CylinderGeometry(capR + 0.1, capR + 0.1, 0.6, 64), matRed);
            ring.position.y = -0.5; capGroup.add(ring);
            const clip = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2.8, 0.5), matRed);
            clip.position.set(capR + 0.05, -2.0, 0); capGroup.add(clip);

            // Initial Layout
            const bodyStartY = 12.0; const capStartY = -14.0;
            const bodyClosedY = 0; const capClosedY = -3.9;
            bodyGroup.position.y = bodyStartY; capGroup.position.y = capStartY;

            // --- 3. ANIMATION CONFIGURATION ---
            // This is where you define the "Dance" for each section
            const isMobile = window.innerWidth < 768;

            const sectionStates = [
                {
                    // STATE 0: HERO (Initial)
                    // Cap Closing Animation happens here separately
                    trigger: ".hero",
                    start: "top top", end: "bottom top",
                    desktop: { x: 6.5, y: 2, z: 0, rotX: 0, rotY: 0, rotZ: -0.78, scale: 1 },
                    mobile: { x: 2.0, y: 1.5, z: 0, rotX: 0, rotY: 0, rotZ: -0.78, scale: 0.4 }
                },
                {
                    // STATE 1: URBANIST (Move to Left Side, Rotate 90 deg)
                    trigger: "#urbanist-integration",
                    start: "top bottom", end: "center center",
                    desktop: { x: -9, y: 0, z: 0, rotX: 0.2, rotY: Math.PI, rotZ: Math.PI - 0.5, scale: 0.9 },
                    mobile: { x: -2, y: -4, z: 0, rotX: 0.2, rotY: Math.PI, rotZ: Math.PI - 0.5, scale: 0.35 }
                },
                {
                    // STATE 2: GRID SCROLL (Move Top Right, Horizontal)
                    trigger: "#grid-scroll-wrapper",
                    start: "top bottom", end: "center center",
                    desktop: { x: 8, y: 4, z: -2, rotX: 0, rotY: Math.PI * 2, rotZ: -1.57, scale: 0.8 },
                    mobile: { x: 2, y: 5, z: -2, rotX: 0, rotY: Math.PI * 2, rotZ: -1.57, scale: 0.35 }
                },
                {
                    // STATE 3: ALICE SECTION (Move Bottom Left, Diagonal Flip)
                    trigger: "#alice-wrapper",
                    start: "top bottom", end: "center center",
                    desktop: { x: -8, y: -3, z: 2, rotX: 0.5, rotY: Math.PI * 3, rotZ: Math.PI - 0.7, scale: 0.9 },
                    mobile: { x: -2, y: -2, z: 2, rotX: 0.5, rotY: Math.PI * 3, rotZ: Math.PI - 0.7, scale: 0.35 }
                },
                {
                    // STATE 4: TEXT/CAPABILITIES (Center Right, Vertical)
                    trigger: ".capabilities-segment",
                    start: "top bottom", end: "center center",
                    desktop: { x: 9, y: 0, z: 0, rotX: 0, rotY: Math.PI * 3.5, rotZ: Math.PI, scale: 0.9 },
                    mobile: { x: 2.5, y: 0, z: 0, rotX: 0, rotY: Math.PI * 3.5, rotZ: Math.PI, scale: 0.35 }
                }
            ];

            // --- 4. APPLY INITIAL POSITION ---
            const startState = isMobile ? sectionStates[0].mobile : sectionStates[0].desktop;
            markerSystem.position.set(startState.x, startState.y, startState.z);
            markerSystem.rotation.set(startState.rotX, startState.rotY, startState.rotZ);
            markerSystem.scale.set(startState.scale, startState.scale, startState.scale);


            // --- 5. CREATE SCROLL TRIGGERS ---

            // A. SPECIAL HERO CAP ANIMATION (Closing the marker)
            const heroTl = gsap.timeline({
                scrollTrigger: {
                    trigger: ".hero",
                    start: "top top",
                    end: "80% top",
                    scrub: 1
                }
            });
            heroTl.to(bodyGroup.position, { y: bodyClosedY, ease: "power2.out" }, 0);
            heroTl.to(capGroup.position, { y: capClosedY, ease: "power2.out" }, 0);


            // B. MOVEMENT ANIMATIONS (Connecting Sections)
            // We skip index 0 because that's our starting point
            for (let i = 1; i < sectionStates.length; i++) {
                const prevState = sectionStates[i - 1];
                const currState = sectionStates[i];

                const prevCfg = isMobile ? prevState.mobile : prevState.desktop;
                const currCfg = isMobile ? currState.mobile : currState.desktop;

                // Create a timeline for this section's transition
                const tl = gsap.timeline({
                    scrollTrigger: {
                        trigger: currState.trigger,
                        start: currState.start,
                        end: currState.end,
                        scrub: isMobile ? 1 : 1.5, // Faster scrub for mobile responsiveness
                    }
                });

                // Position
                tl.fromTo(markerSystem.position,
                    { x: prevCfg.x, y: prevCfg.y, z: prevCfg.z },
                    { x: currCfg.x, y: currCfg.y, z: currCfg.z, ease: "power1.inOut", immediateRender: false },
                    0
                );

                // Rotation
                tl.fromTo(markerSystem.rotation,
                    { x: prevCfg.rotX, y: prevCfg.rotY, z: prevCfg.rotZ },
                    { x: currCfg.rotX, y: currCfg.rotY, z: currCfg.rotZ, ease: "power1.inOut", immediateRender: false },
                    0
                );

                // Scale
                tl.fromTo(markerSystem.scale,
                    { x: prevCfg.scale, y: prevCfg.scale, z: prevCfg.scale },
                    { x: currCfg.scale, y: currCfg.scale, z: currCfg.scale, ease: "power1.inOut", immediateRender: false },
                    0
                );
            }


            // C. HIDE MARKER AT PRIME INK SECTION
            gsap.to(container, {
                opacity: 0,
                duration: 0.5,
                ease: "power2.inOut",
                scrollTrigger: {
                    trigger: ".hero-reveal",
                    start: "top center",
                    toggleActions: "play none none reverse"
                }
            });


            // --- 6. RENDER LOOP (With Floating Motion) ---
            function animate() {
                requestAnimationFrame(animate);
                const t = Date.now() * 0.001;

                // Independent Idle Animation (Sine Waves)
                // This happens on TOP of the GSAP scrolling movement
                floatGroup.position.y = Math.sin(t * 1.5) * 0.3; // Bob up/down
                floatGroup.rotation.x = Math.sin(t * 1.2) * 0.1; // Gentle tilt
                floatGroup.rotation.z = Math.cos(t * 0.9) * 0.1; // Gentle sway

                renderer.render(scene, camera);
            }
            animate();


            // --- 7. RESIZE HANDLER ---
            function onResize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
                // Note: We don't reset positions here to avoid conflict with ScrollTrigger
                // A full refresh is better for responsive layout changes
            }
            window.addEventListener('resize', onResize);
        }</script>
    <script>
        function initGlobalTextAnimations() {
            const textElements = document.querySelectorAll("h1, h2, h3, h4, p, li, span.footer-big-text");

            textElements.forEach((element) => {
                if (element.closest('.loader-screen')) return;
                if (element.closest('.hero__title')) return;
                if (element.closest('.kinetic-typography-block')) return;
                if (element.closest('#panes-container')) return;

                gsap.fromTo(element,
                    {
                        y: 50,
                        opacity: 0,
                        clipPath: "polygon(0 0, 100% 0, 100% 0, 0 0)"
                    },
                    {
                        y: 0,
                        opacity: 1,
                        clipPath: "polygon(0 0, 100% 0, 100% 100%, 0 100%)",
                        duration: 1,
                        ease: "power3.out",
                        scrollTrigger: {
                            trigger: element,
                            start: "top 90%",
                            toggleActions: "play none none reverse"
                        }
                    }
                );
            });
        }
    </script>
    <script>
        function initMobileHeadingEffect() {
            ScrollTrigger.matchMedia({

                // Target Mobile Screens (max-width 768px)
                "(max-width: 768px)": function () {

                    gsap.to(".intro__heading", {
                        y: 420,
                        opacity: 1,
                        ease: "none",
                        scrollTrigger: {
                            trigger: ".intro",
                            start: "top 40%",
                            end: "bottom top",
                            scrub: 1
                        }
                    });

                }
            });
        }
    </script>
    <script>
        (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const l of document.querySelectorAll('link[rel="modulepreload"]')) o(l); new MutationObserver(l => { for (const n of l) if (n.type === "childList") for (const a of n.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && o(a) }).observe(document, { childList: !0, subtree: !0 }); function s(l) { const n = {}; return l.integrity && (n.integrity = l.integrity), l.referrerPolicy && (n.referrerPolicy = l.referrerPolicy), l.crossOrigin === "use-credentials" ? n.credentials = "include" : l.crossOrigin === "anonymous" ? n.credentials = "omit" : n.credentials = "same-origin", n } function o(l) { if (l.ep) return; l.ep = !0; const n = s(l); fetch(l.href, n) } })(); let slideUp = (e, t = 500, s = 0) => { e.classList.contains("--slide") || (e.classList.add("--slide"), e.style.transitionProperty = "height, margin, padding", e.style.transitionDuration = t + "ms", e.style.height = `${e.offsetHeight}px`, e.offsetHeight, e.style.overflow = "hidden", e.style.height = s ? `${s}px` : "0px", e.style.paddingTop = 0, e.style.paddingBottom = 0, e.style.marginTop = 0, e.style.marginBottom = 0, window.setTimeout(() => { e.hidden = !s, s || e.style.removeProperty("height"), e.style.removeProperty("padding-top"), e.style.removeProperty("padding-bottom"), e.style.removeProperty("margin-top"), e.style.removeProperty("margin-bottom"), s || e.style.removeProperty("overflow"), e.style.removeProperty("transition-duration"), e.style.removeProperty("transition-property"), e.classList.remove("--slide"), document.dispatchEvent(new CustomEvent("slideUpDone", { detail: { target: e } })) }, t)) }, slideDown = (e, t = 500, s = 0) => { if (!e.classList.contains("--slide")) { e.classList.add("--slide"), e.hidden = e.hidden ? !1 : null, s && e.style.removeProperty("height"); let o = e.offsetHeight; e.style.overflow = "hidden", e.style.height = s ? `${s}px` : "0px", e.style.paddingTop = 0, e.style.paddingBottom = 0, e.style.marginTop = 0, e.style.marginBottom = 0, e.offsetHeight, e.style.transitionProperty = "height, margin, padding", e.style.transitionDuration = t + "ms", e.style.height = o + "px", e.style.removeProperty("padding-top"), e.style.removeProperty("padding-bottom"), e.style.removeProperty("margin-top"), e.style.removeProperty("margin-bottom"), window.setTimeout(() => { e.style.removeProperty("height"), e.style.removeProperty("overflow"), e.style.removeProperty("transition-duration"), e.style.removeProperty("transition-property"), e.classList.remove("--slide"), document.dispatchEvent(new CustomEvent("slideDownDone", { detail: { target: e } })) }, t) } }, slideToggle = (e, t = 500) => e.hidden ? slideDown(e, t) : slideUp(e, t), bodyLockStatus = !0, bodyLockToggle = (e = 500) => { document.documentElement.hasAttribute("data-fls-scrolllock") ? bodyUnlock(e) : bodyLock(e) }, bodyUnlock = (e = 500) => { if (bodyLockStatus) { const t = document.querySelectorAll("[data-fls-lp]"); setTimeout(() => { t.forEach(s => { s.style.paddingRight = "" }), document.body.style.paddingRight = "", document.documentElement.removeAttribute("data-fls-scrolllock") }, e), bodyLockStatus = !1, setTimeout(function () { bodyLockStatus = !0 }, e) } }, bodyLock = (e = 500) => { if (bodyLockStatus) { const t = document.querySelectorAll("[data-fls-lp]"), s = window.innerWidth - document.body.offsetWidth + "px"; t.forEach(o => { o.style.paddingRight = s }), document.body.style.paddingRight = s, document.documentElement.setAttribute("data-fls-scrolllock", ""), bodyLockStatus = !1, setTimeout(function () { bodyLockStatus = !0 }, e) } }; function uniqArray(e) { return e.filter((t, s, o) => o.indexOf(t) === s) } function dataMediaQueries(e, t) { const s = Array.from(e).filter(n => n.dataset[t]).map(n => { const [a, d = "max"] = n.dataset[t].split(","); return { value: a, type: d, item: n } }); if (s.length === 0) return []; const o = s.map(({ value: n, type: a }) => `(${a}-width: ${n}px),${n},${a}`); return [...new Set(o)].map(n => { const [a, d, f] = n.split(","), p = window.matchMedia(a); return { itemsArray: s.filter(r => r.value === d && r.type === f), matchMedia: p } }) } function spollers() { const e = document.querySelectorAll("[data-fls-spollers]"); if (e.length > 0) { let n = function (r, u = !1) { r.forEach(i => { i = u ? i.item : i, u.matches || !u ? (i.classList.add("--spoller-init"), a(i)) : (i.classList.remove("--spoller-init"), a(i, !1)) }) }, a = function (r, u = !0) { let i = r.querySelectorAll("details"); i.length && i.forEach(c => { let h = c.querySelector("summary"); u ? (h.removeAttribute("tabindex"), c.hasAttribute("data-fls-spollers-open") ? (h.classList.add("--spoller-active"), c.open = !0) : (c.open = !1, h.nextElementSibling.hidden = !0)) : (h.setAttribute("tabindex", "-1"), h.classList.remove("--spoller-active"), c.open = !0, h.nextElementSibling.hidden = !1) }) }, d = function (r) { const u = r.target; if (u.closest("summary") && u.closest("[data-fls-spollers]") && (r.preventDefault(), u.closest("[data-fls-spollers]").classList.contains("--spoller-init"))) { const i = u.closest("summary"), c = i.closest("details"), h = i.closest("[data-fls-spollers]"), v = h.hasAttribute("data-fls-spollers-one"), y = c.hasAttribute("data-fls-spollers-scroll"), g = h.dataset.flsSpollersSpeed ? parseInt(h.dataset.flsSpollersSpeed) : 500; if (!h.querySelectorAll(".--slide").length && (v && !c.open && f(h), c.open ? setTimeout(() => { c.open = !1 }, g) : c.open = !0, i.classList.toggle("--spoller-active"), slideToggle(i.nextElementSibling, g), y && i.classList.contains("--spoller-active"))) { const w = c.dataset.flsSpollersScroll, S = +w ? +w : 0, L = c.hasAttribute("data-fls-spollers-scroll-noheader") ? document.querySelector(".header").offsetHeight : 0; window.scrollTo({ top: c.offsetTop - (S + L), behavior: "smooth" }) } } if (!u.closest("[data-fls-spollers]")) { const i = document.querySelectorAll("[data-fls-spollers-close]"); i.length && i.forEach(c => { const h = c.closest("[data-fls-spollers]"), v = c.parentNode; if (h.classList.contains("--spoller-init")) { const y = h.dataset.flsSpollersSpeed ? parseInt(h.dataset.flsSpollersSpeed) : 500; c.classList.remove("--spoller-active"), slideUp(c.nextElementSibling, y), setTimeout(() => { v.open = !1 }, y) } }) } }, f = function (r) { const u = r.querySelector("details[open]"); if (u && !r.querySelectorAll(".--slide").length) { const i = u.querySelector("summary"), c = r.dataset.flsSpollersSpeed ? parseInt(r.dataset.flsSpollersSpeed) : 500; i.classList.remove("--spoller-active"), slideUp(i.nextElementSibling, c), setTimeout(() => { u.open = !1 }, c) } }; var t = n, s = a, o = d, l = f; document.addEventListener("click", d); const p = Array.from(e).filter(function (r, u, i) { return !r.dataset.flsSpollers.split(",")[0] }); p.length && n(p); let m = dataMediaQueries(e, "flsSpollers"); m && m.length && m.forEach(r => { r.matchMedia.addEventListener("change", function () { n(r.itemsArray, r.matchMedia) }), n(r.itemsArray, r.matchMedia) }) } } window.addEventListener("load", spollers); function menuInit() { document.addEventListener("click", function (e) { bodyLockStatus && e.target.closest("[data-fls-menu]") && (bodyLockToggle(), document.documentElement.toggleAttribute("data-fls-menu-open")) }) } document.querySelector("[data-fls-menu]") && window.addEventListener("load", menuInit), document.addEventListener("DOMContentLoaded", () => { if (window.matchMedia("(hover: none) and (pointer: coarse)").matches) return; const t = document.querySelectorAll(".menu__link"), s = document.getElementById("videoWrapper"), o = document.getElementById("video"); let l = !1; t.forEach((n, a) => { n.addEventListener("mouseenter", () => { l = !1; const d = n.dataset.video; if (!d) return; o.src = d, o.load(), s.classList.remove("menu__video-wrapper--fade", "menu__video-wrapper--wide", "menu__video-wrapper--hidden"); const f = a === 0, p = a === t.length - 1; s.classList.add(f || p ? "menu__video-wrapper--wide" : "menu__video-wrapper--fade") }), n.addEventListener("mouseleave", () => { l = !0, s.classList.remove("menu__video-wrapper--fade", "menu__video-wrapper--wide"); const d = () => { l && (s.classList.add("menu__video-wrapper--hidden"), o.src = ""), s.removeEventListener("transitionend", d) }; s.addEventListener("transitionend", d) }) }) }); function headerScroll() { const e = document.querySelector("[data-fls-header-scroll]"), t = e.hasAttribute("data-fls-header-scroll-show"), s = e.dataset.flsHeaderScrollShow ? e.dataset.flsHeaderScrollShow : 500, o = e.dataset.flsHeaderScroll ? e.dataset.flsHeaderScroll : 1; let l = 0, n; document.addEventListener("scroll", function (a) { const d = window.scrollY; clearTimeout(n), d >= o ? (e.classList.contains("--header-scroll") || e.classList.add("--header-scroll"), t && (d > l ? e.classList.contains("--header-show") && e.classList.remove("--header-show") : e.classList.contains("--header-show") || e.classList.add("--header-show"), n = setTimeout(() => { e.classList.contains("--header-show") || e.classList.add("--header-show") }, s))) : (e.classList.contains("--header-scroll") && e.classList.remove("--header-scroll"), t && e.classList.contains("--header-show") && e.classList.remove("--header-show")), l = d <= 0 ? 0 : d }) } document.querySelector("[data-fls-header-scroll]") && window.addEventListener("load", headerScroll); class ScrollWatcher { constructor(t) { let s = { logging: !0 }; this.config = Object.assign(s, t), this.observer, document.documentElement.classList.contains("watcher") || this.scrollWatcherRun() } scrollWatcherUpdate() { this.scrollWatcherRun() } scrollWatcherRun() { document.documentElement.classList.add("watcher"), this.scrollWatcherConstructor(document.querySelectorAll("[data-fls-watcher]")) } scrollWatcherConstructor(t) { t.length && uniqArray(Array.from(t).map(function (o) { if (o.dataset.flsWatcher === "navigator" && !o.dataset.flsWatcherThreshold) { let l; o.clientHeight > 2 ? (l = window.innerHeight / 2 / (o.clientHeight - 1), l > 1 && (l = 1)) : l = 1, o.setAttribute("data-fls-watcher-threshold", l.toFixed(2)) } return `${o.dataset.flsWatcherRoot ? o.dataset.flsWatcherRoot : null}|${o.dataset.flsWatcherMargin ? o.dataset.flsWatcherMargin : "0px"}|${o.dataset.flsWatcherThreshold ? o.dataset.flsWatcherThreshold : 0}` })).forEach(o => { let l = o.split("|"), n = { root: l[0], margin: l[1], threshold: l[2] }, a = Array.from(t).filter(function (f) { let p = f.dataset.flsWatcherRoot ? f.dataset.flsWatcherRoot : null, m = f.dataset.flsWatcherMargin ? f.dataset.flsWatcherMargin : "0px", r = f.dataset.flsWatcherThreshold ? f.dataset.flsWatcherThreshold : 0; if (String(p) === n.root && String(m) === n.margin && String(r) === n.threshold) return f }), d = this.getScrollWatcherConfig(n); this.scrollWatcherInit(a, d) }) } getScrollWatcherConfig(t) { let s = {}; if (document.querySelector(t.root) ? s.root = document.querySelector(t.root) : t.root, s.rootMargin = t.margin, !(t.margin.indexOf("px") < 0 && t.margin.indexOf("%") < 0)) { if (t.threshold === "prx") { t.threshold = []; for (let o = 0; o <= 1; o += .005)t.threshold.push(o) } else t.threshold = t.threshold.split(","); return s.threshold = t.threshold, s } } scrollWatcherCreate(t) { this.observer = new IntersectionObserver((s, o) => { s.forEach(l => { this.scrollWatcherCallback(l, o) }) }, t) } scrollWatcherInit(t, s) { this.scrollWatcherCreate(s), t.forEach(o => this.observer.observe(o)) } scrollWatcherIntersecting(t, s) { t.isIntersecting ? s.classList.contains("--watcher-view") || s.classList.add("--watcher-view") : s.classList.contains("--watcher-view") && s.classList.remove("--watcher-view") } scrollWatcherOff(t, s) { s.unobserve(t) } scrollWatcherCallback(t, s) { const o = t.target; this.scrollWatcherIntersecting(t, o), o.hasAttribute("data-fls-watcher-once") && t.isIntersecting && this.scrollWatcherOff(o, s), document.dispatchEvent(new CustomEvent("watcherCallback", { detail: { entry: t } })) } } document.querySelector("[data-fls-watcher]") && window.addEventListener("load", () => new ScrollWatcher({})); const canvas = document.getElementById("hero-canvas");
        const ctx = canvas.getContext("2d");
        let lastPos = null;

        // Force touch-action none to prevent scrolling on the canvas
        canvas.style.touchAction = "none";

        function resizeCanvas() {
            // Handle High DPI (Retina) displays correctly
            const dpr = window.devicePixelRatio || 1;

            // Set internal buffer size to match device pixels
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;

            // CSS size remains consistent with the viewport
            canvas.style.width = window.innerWidth + "px";
            canvas.style.height = window.innerHeight + "px";

            // Reset any previous transforms
            ctx.setTransform(1, 0, 0, 1, 0, 0);

            // Scale context to match audio pixel density
            ctx.scale(dpr, dpr);

            // Fill with white
            ctx.globalCompositeOperation = "source-over";
            ctx.fillStyle = "#fff";
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

            // Prepare for 'scratch' (erasing)
            ctx.globalCompositeOperation = "destination-out";
            ctx.lineCap = "round";
            ctx.lineWidth = 70;
            ctx.strokeStyle = "rgba(0,0,0,1)"; // Color doesn't matter for destination-out, alpha does
        }

        // Initialize and listen for resize with redundancy for mobile
        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);
        window.addEventListener("load", resizeCanvas);
        // Fallback for mobile browser address bar shifts
        setTimeout(resizeCanvas, 500);

        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            // Support both mouse and touch
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function draw(e) {
            // Important: prevent scrolling on touch devices
            if (e.type === 'touchmove') {
                e.preventDefault();
            }

            const { x, y } = getCoords(e);

            ctx.beginPath();
            if (lastPos) {
                ctx.moveTo(lastPos.x, lastPos.y);
                ctx.lineTo(x, y);
                ctx.stroke();
            }
            lastPos = { x, y };
        }

        function handleStart(e) {
            if (e.type === 'touchstart') {
                e.preventDefault();
            }
            const { x, y } = getCoords(e);
            lastPos = { x, y };
        }

        function handleEnd() {
            lastPos = null;
        }

        // Mouse Events
        canvas.addEventListener("mousemove", draw);
        canvas.addEventListener("mouseleave", handleEnd);
        // We can add mousedown if we wanted click-to-erase logic, but staying with hover-erase for desktop as per original.

        // Touch Events
        // Passive: false is crucial for preventDefault() to work
        canvas.addEventListener("touchstart", handleStart, { passive: false });
        canvas.addEventListener("touchmove", draw, { passive: false });
        canvas.addEventListener("touchend", handleEnd);

        const cursor = document.querySelector(".custom-cursor"); cursor || console.warn("No .custom-cursor found"); const interactiveSelector = ["a[href]", "button", "canvas", '[role="button"]', "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", '[data-cursor="interactive"]'].join(","), stickyItems = document.querySelectorAll(".sticky-item"); let isSticky = !1; function isPureBlack(e) { if (!e || !e.startsWith("rgb")) return !1; const [t, s, o] = e.match(/\d+/g).map(Number); return t === 0 && s === 0 && o === 0 } function isBackgroundBlack(e) { for (; e && e !== document.body;) { const t = getComputedStyle(e).backgroundColor; if (t !== "rgba(0, 0, 0, 0)" && !isPureBlack(t)) return !1; e = e.parentElement } return !0 } function getAllElementsAt(e, t) { const s = [], o = []; let l; for (; (l = document.elementFromPoint(e, t)) && !s.includes(l);)s.push(l), o.push({ el: l, pe: l.style.pointerEvents }), l.style.pointerEvents = "none"; return o.forEach(({ el: n, pe: a }) => n.style.pointerEvents = a), s } let rAF = null; function handlePointerMove(e) { rAF || (rAF = requestAnimationFrame(() => { isSticky || (cursor.style.transform = `translate(${e.clientX}px, ${e.clientY}px) translate(-50%, -50%)`); const s = getAllElementsAt(e.clientX, e.clientY).every(isBackgroundBlack); cursor.classList.toggle("red", s); const o = document.elementFromPoint(e.clientX, e.clientY), l = o && o.closest(interactiveSelector); cursor.classList.toggle("--interactive", !!l), rAF = null })) } document.addEventListener("mousemove", handlePointerMove), stickyItems.forEach(e => { e.addEventListener("mouseenter", () => { const t = e.getBoundingClientRect(), s = t.left + t.width / 2, o = t.top + t.height / 2; cursor.classList.add("--sticky"), cursor.style.transform = `translate(${s}px, ${o}px) translate(-50%, -50%)`, isSticky = !0 }), e.addEventListener("mouseleave", () => { cursor.classList.remove("--sticky"), isSticky = !1 }) }), document.addEventListener("mouseleave", () => cursor.style.opacity = "0"), document.addEventListener("mouseenter", () => cursor.style.opacity = "1");
    </script>
</body>

</html>