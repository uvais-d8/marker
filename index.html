<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARKER</title>
    <!-- Fonts -->
    <link rel="preload" href="./assets/fonts/Presicav.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="./assets/fonts/Calibre-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="./assets/fonts/Arial.woff2" as="font" type="font/woff2" crossorigin="anonymous">

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://api.fontshare.com/v2/css?f[]=neue-montreal@500&display=swap" rel="stylesheet">

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    <script src="https://unpkg.com/lenis@1.1.20/dist/lenis.min.js"></script>
    <script type="module" crossorigin src="./js/index.min.js?v=1754734869502"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

    <link rel="stylesheet" crossorigin href="./css/index.min.css?v=1754734869502">
    <link rel="stylesheet" href="./style.css">

</head>

<body class="is-loading">

    <canvas id="global-cursor-canvas"></canvas>

    <div id="threejs-marker-container"></div>
    <section class="loader-screen">
        <div class="loader-content">
            <div class="willem__h1">
                <div class="willem__h1-start">
                    <span class="willem__letter">M</span>
                    <span class="willem__letter">A</span>
                    <span class="willem__letter">R</span>
                </div>
                <div class="willem-loader__box">
                    <div class="willem-loader__box-inner">
                        <div class="willem__growing-image">
                            <div class="willem__growing-image-wrap">
                                <img class="willem__cover-image-extra is--1" src="./assets/marker1.jpg" loading="lazy"
                                    alt="">
                                <img class="willem__cover-image-extra is--2" src="./assets/marker2.jpeg" loading="lazy"
                                    alt="">
                                <img class="willem__cover-image-extra is--3" src="./assets/marker3.webp" loading="lazy"
                                    alt="">
                                <img class="willem__cover-image" src='./assets/white.png' loading="lazy" alt="">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="willem__h1-end">
                    <span class="willem__letter">K</span>
                    <span class="willem__letter">E</span>
                    <span class="willem__letter">R</span>
                </div>
            </div>
        </div>
    </section>

    <div class="wrapper">
        <header class="header fade" data-fls-header="" data-fls-header-scroll="" data-fls-header-scroll-show="">
            <div class="header__container">
                <div class="header__menu menu">
                    <h1 class="logo">
                        <a href="#">MARKER</a>
                    </h1>
                </div>
            </div>
        </header>

        <main class="page page--home">

            <section class="hero">
                <video class="hero__video" src="./files/banner-hero.mov" autoplay muted loop playsinline=""></video>
                <canvas class="hero__canvas" id="hero-canvas"></canvas>
                <h1 class="hero__title" data-fls-watcher="" data-fls-watcher-once="">
                    <span>MARKER</span>
                </h1>
            </section>
            <section id="urbanist-integration">
                <svg class="urbanist-bg" width="100%" viewBox="0 0 1920 1300" fill="none"
                    xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none">
                    <rect width="1920" height="1300" fill="url(#gradient)"></rect>
                    <defs>
                        <linearGradient id="gradient" x1="1300.54" y1="201.621" x2="959.727" y2="841.863"
                            gradientUnits="userSpaceOnUse">
                            <stop offset="0.15" stop-color="var(--theme-sub-bg)" stop-opacity="1"></stop>
                            <stop offset="0.85" stop-color="var(--theme-main-bg)"></stop>
                        </linearGradient>
                    </defs>
                </svg>

                <div class="content-layer">
                    <h1>Marker</h1>
                    <p class="desc-1">
                        The Marker font captures the spontaneous energy and look of a broad-tipped permanent
                        marker, offering a bold and authentic hand-drawn aesthetic for digital interfaces.
                    </p>
                    <p class="desc-2">
                        Characterized by its irregular edges, organic flow, and varying stroke weights, it
                        breaks away from rigid digital grids to deliver a raw, human touch.
                    </p>
                    <p class="desc-3">
                        Ideal for impactful headlines and creative overlays, this typeface transforms
                        standard typography into expressive, attention-grabbing visual statements.
                    </p>
                </div>

                <div id="panes-container">
                    <div class="pane">
                        <img class="urbanist-floating-img" src="./assets/blue.png" alt="Marker design inspiration 1">
                    </div>
                    <div class="pane">
                        <img class="urbanist-floating-img" src="./assets/orange.png" alt="Marker design inspiration 2">
                    </div>
                    <div class="pane">
                        <img class="urbanist-floating-img" src="./assets/green.png" alt="Marker design inspiration 3">
                    </div>
                </div>
            </section>
            <section id="grid-scroll-wrapper">
                <section style="margin-bottom: -200px;" class="section-stick">
                    <p class="opacity-reveal reveal-text-style">
                        If you’re bold, a single marker stroke will break the grid, steal the show, and change
                        everything.
                    </p>
                </section>
            </section>
            <div id="alice-wrapper">
                <section class="intro">
                    <h1 class="intro__heading">Marker Colour Priority and Visual Hierarchy</h1>
                </section>
                <section class="content">
                    <article class="article">
                        <h4 style="margin-top: 20px;color: red;"><b>Red Marker (Highest Priority)</b></h4>
                        <p>
                            RED is the most attention-grabbing marker colour. It represents urgency,
                            <b>danger</b>, and high
                            <b>importance</b>,
                            making it ideal for warnings and critical highlights.
                        </p>
                        <p class="mobile-hidden">
                            Its strong visual impact ensures immediate focus, so it is used carefully and with clear
                            intention.
                        </p>

                        <h4 style="margin-top: 20px;color: black;"><b>Black Marker</b></h4>
                        <p>
                            BLACK symbolizes clarity and authority. It is widely used for writing, outlining, and
                            clear
                            <b>communication</b> due to its high readability .
                        </p>
                        <p class="mobile-hidden">
                            Because of its professional appearance, black is preferred for formal and final work.
                        </p>

                        <h4 style="margin-top: 20px;color: blue;"><b>Blue Marker</b></h4>
                        <p>
                            BLUE represents trust and <b>calmness</b>. It is commonly used for general writing
                            and explanations
                            without creating visual stress.
                        </p>
                        <p class="mobile-hidden">
                            This colour is suitable for notes and planning where balance and clarity are needed.
                        </p>

                        <h4 style="margin-top: 20px;color: green;"><b>Green Marker (Lowest Priority)</b></h4>
                        <p>
                            GREEN stands for positivity and <b>approval</b>. It is often used to show
                            <b>correctness</b> or progress.
                        </p>
                        <p class="mobile-hidden">
                            With lower urgency, green works best for supportive and secondary highlights.
                        </p>
                    </article>
                </section>
                <div class="hero-reveal-wrapper">
                    <section class="hero-reveal">
                        <article>
                            <header class="hero-reveal__header">
                                <div class="hero-reveal_split">
                                    <div class="hero-reveal_split_item">
                                        <p>PRIME INK</p>
                                    </div>
                                    <div class="hero-reveal_split_item" aria-hidden="true">
                                        <p aria-hidden="true">PRIME INK</p>
                                    </div>
                                </div>
                            </header>

                            <div class="hero-reveal__content">
                                <div class="hero-reveal__content-inner">
                                    <div class="hero-reveal__parallax">
                                        <img src="https://assets.codepen.io/204808/alice-falling-1.png" alt="Alice"
                                            class="hero-reveal__parallax-alice" />
                                        <img width="150" src="https://assets.codepen.io/204808/alice-falling-clock.png"
                                            alt="Clock" class="hero-reveal__parallax-clock" />
                                        <img width="100" src="https://assets.codepen.io/204808/alice-falling-book.png"
                                            alt="Book" class="hero-reveal__parallax-book" />
                                        <img width="50" src="https://assets.codepen.io/204808/alice-falling-kattle.png"
                                            alt="Kattle" class="hero-reveal__parallax-kattle" />
                                        <img width="330" src="https://assets.codepen.io/204808/alice-falling-card.png"
                                            alt="Card" class="hero-reveal__parallax-card" />
                                    </div>

                                    <div class="hero-reveal__content-p">
                                        <p>
                                            <B>The ink of the marker</B> flowed with confidence, bold and consistent,
                                            leaving
                                            behind a stroke that felt
                                            <B>permanent and intentional</B>. It dried quickly on the surface, resisting
                                            smudges, while the pigment
                                            settled deep into the material, giving the line its strong and lasting
                                            presence.
                                        </p>
                                        <p class="mobile-hidden">
                                            As the marker moved, the ink revealed its character — rich in color,
                                            balanced in density, and smooth
                                            in motion. Each stroke carried clarity, allowing ideas to take shape without
                                            interruption or loss
                                            of control.
                                        </p>
                                        <p>
                                            Unlike ordinary pens, marker ink is designed to command attention. Its
                                            formulation blends pigments
                                            and solvents carefully, ensuring even coverage while maintaining durability
                                            across different
                                            surfaces and textures.
                                        </p>
                                        <p class="mobile-hidden">
                                            <B>“This is not just ink,”</B> the creator realized, <B>“it is expression
                                                itself.”</B>
                                            With every line drawn, the
                                            marker transformed thought into form, leaving marks that spoke with
                                            strength, precision, and purpose.
                                        </p>
                                    </div>

                                </div>
                            </div>
                        </article>
                    </section>
                </div>

            </div>
            <section class="viewport-section intro-viewport">
                <div class="content-wrapper">
                    <h1>A creative marker built for clarity, control, and expression.</h1>
                </div>
            </section>
            <section class="viewport-section narrative-segment scroll-sequence-host">
                <div class="content-wrapper">
                    <div class="kinetic-typography-block">
                        <p>
                            Marker is designed as a focused tool for creators who value precision
                            and intention. Every stroke carries meaning, and every interaction is
                            crafted to feel natural, responsive, and purposeful.
                        </p>
                        <p>
                            More than a simple tool, Marker adapts to your workflow. It gives you
                            control over form, movement, and structure while staying effortless
                            to use. From quick ideas to refined details, Marker supports the way
                            you think and create.
                        </p>
                    </div>
                </div>
            </section>
            <section class="viewport-section action-trigger-zone">
                <div class="content-wrapper">
                    <h1>Create with confidence using Marker’s powerful tools.</h1>
                </div>
            </section>
            <section class="viewport-section capabilities-segment scroll-sequence-host">
                <div class="content-wrapper">
                    <div class="kinetic-typography-block">
                        <p>
                            Marker offers smooth interactions, adaptive precision, and intelligent
                            responsiveness in every feature. Whether you are highlighting ideas,
                            shaping concepts, or guiding attention, Marker reacts instantly and
                            accurately to your intent.
                        </p>
                        <p>
                            With optimized performance, flexible controls, and real-time feedback,
                            Marker transforms simple actions into expressive outcomes. It is built
                            to stay out of your way while enhancing every moment of creation.
                        </p>
                    </div>
                </div>
            </section>
            <section class="viewport-section conclusion-viewport">
                <div class="content-wrapper">
                    <h1>Marker empowers creators to define ideas with purpose.</h1>
                </div>
            </section>
<section id="drawing-playground" class="viewport-section" data-lenis-prevent>
                <div class="playground-wrapper">
                    
                    <div class="playground-ui">
                        <div class="ui-header">
                            <h3>Test the Ink</h3>
                            <p>Draw anywhere.</p>
                        </div>
                        
                        <div class="color-picker">
                            <button class="color-btn active" data-color="#000000" style="background-color: #000000;"></button>
                            <button class="color-btn" data-color="#d91c24" style="background-color: #d91c24;"></button> <button class="color-btn" data-color="#2b4eff" style="background-color: #2b4eff;"></button> <button class="color-btn" data-color="#00a651" style="background-color: #00a651;"></button> </div>

                        <div class="tools-picker">
                            <button id="btn-marker" class="tool-btn active">Marker</button>
                            <button id="btn-eraser" class="tool-btn">Eraser</button>
                        </div>

                        <button id="btn-clear" class="action-btn">Clear Canvas</button>
                    </div>

                    <canvas id="playground-canvas"></canvas>
                </div>
            </section>
<script>
        // --- DRAWING PLAYGROUND LOGIC ---
        function initPlayground() {
            const canvas = document.getElementById('playground-canvas');
            const container = document.getElementById('drawing-playground');
            
            if (!canvas || !container) return;

            const ctx = canvas.getContext('2d');
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;
            
            // Default Settings
            let currentColor = '#000000';
            let currentLineWidth = 8;
            let isEraser = false;

            // 1. Setup Canvas Size (High DPI support)
            function resizePlayground() {
                const rect = container.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';
                
                ctx.scale(dpr, dpr);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
            }

            // Initial Resize
            resizePlayground();
            window.addEventListener('resize', resizePlayground);

            // 2. Drawing Functions
            function startDrawing(e) {
                isDrawing = true;
                const { x, y } = getPos(e);
                lastX = x;
                lastY = y;
                
                // Draw a single dot if clicked
                draw(e);
            }

            function stopDrawing() {
                isDrawing = false;
                ctx.beginPath(); // Reset path to prevent connecting lines
            }

            function draw(e) {
                if (!isDrawing) return;
                
                // Prevent scrolling on mobile touches
                if(e.type === 'touchmove') e.preventDefault();

                const { x, y } = getPos(e);

                ctx.lineWidth = isEraser ? 40 : currentLineWidth;
                
                if (isEraser) {
                    ctx.globalCompositeOperation = 'destination-out'; // Erase transparency
                } else {
                    ctx.globalCompositeOperation = 'source-over'; // Draw Color
                    ctx.strokeStyle = currentColor;
                }

                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();

                lastX = x;
                lastY = y;
            }

            // Helper to get mouse/touch coordinates relative to canvas
            function getPos(e) {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }

            // 3. Event Listeners (Mouse & Touch)
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            canvas.addEventListener('touchstart', startDrawing, { passive: false });
            canvas.addEventListener('touchmove', draw, { passive: false });
            canvas.addEventListener('touchend', stopDrawing);

            // 4. UI Controls
            const colorBtns = document.querySelectorAll('.color-btn');
            const btnMarker = document.getElementById('btn-marker');
            const btnEraser = document.getElementById('btn-eraser');
            const btnClear = document.getElementById('btn-clear');

            // Handle Color Selection
            colorBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // Update Active State
                    colorBtns.forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // Switch to Marker Mode automatically
                    isEraser = false;
                    currentColor = e.target.dataset.color;
                    
                    // Update Tool UI
                    btnEraser.classList.remove('active');
                    btnMarker.classList.add('active');
                });
            });

            // Handle Marker Tool
            btnMarker.addEventListener('click', () => {
                isEraser = false;
                btnMarker.classList.add('active');
                btnEraser.classList.remove('active');
            });

            // Handle Eraser Tool
            btnEraser.addEventListener('click', () => {
                isEraser = true;
                btnEraser.classList.add('active');
                btnMarker.classList.remove('active');
                // Remove active class from colors strictly for visual feedback
                colorBtns.forEach(b => b.classList.remove('active'));
            });

            // Handle Clear Board
            btnClear.addEventListener('click', () => {
                const rect = container.getBoundingClientRect();
                ctx.clearRect(0, 0, rect.width, rect.height);
            });
        }

        // Initialize when DOM is ready (Add this to your existing listener)
        document.addEventListener("DOMContentLoaded", () => {
            initPlayground(); 
        });
    </script>
            <footer id="advanced-footer">

                <div class="footer-container">

                    <div class="footer-cta-section">
                        <div class="cta-text-wrapper">
                            <span class="cta-label">Have an idea?</span>
                            <h2 class="cta-big-text" data-fls-typed="duration:0.6; stagger:0.04;">
                                DEFINING CLARITY THROUGH INK</h2>
                        </div>
                        <a href="#contact" class="magnetic-button  mobile-hidden">
                            <div class="btn-fill"></div>
                            <span class="btn-text">Get in Touch</span>
                            <span class="btn-icon">↗</span>
                        </a>
                    </div>

                    <div class="footer-marquee">
                        <div class="track">
                            <div class="content">
                                MARKER DIGITAL — PRECISION TOOLS — MARKER DIGITAL — PRECISION TOOLS — MARKER DIGITAL —
                                PRECISION TOOLS —
                                MARKER DIGITAL — PRECISION TOOLS — MARKER DIGITAL — PRECISION TOOLS — MARKER DIGITAL —
                                PRECISION TOOLS —
                            </div>
                        </div>
                    </div>

                    <div class="footer-grid">
                        <div class="grid-col brand-col">
                            <div class="footer-lamp-wrapper">
                                <div class="lamp">
                                    <div class="line"></div>
                                    <div class="base">
                                        <div class="light"></div>
                                    </div>
                                </div>
                                <div class="lamp-text">
                                    <span style="margin-top: 70px;color: rgb(87, 87, 87);">MARKER</span>
                                </div>
                            </div>
                            <p style="margin-top: 1rem; opacity: 0.5;">Est. 2025</p>
                        </div>
                        <div class="grid-col links-col">
                            <h4>Socials</h4>
                            <ul>
                                <li><a href="#" class="hover-link">Instagram</a></li>
                                <li><a href="#" class="hover-link">LinkedIn</a></li>
                                <li><a href="#" class="hover-link">Twitter / X</a></li>
                                <li><a href="#" class="hover-link">Behance</a></li>
                            </ul>
                        </div>

                        <div class="grid-col newsletter-col">
                            <h4>Stay Updated</h4>
                            <form class="newsletter-form">
                                <input type="email" placeholder="Email address" required>
                                <button type="submit">→</button>
                            </form>
                        </div>
                    </div>

                    <div class="footer-bottom">
                        <div class="meta-left">
                            <span>© 2025 Marker Digital.</span>
                        </div>
                        <div class="meta-right">
                            <a href="#" class="scroll-top-btn"
                                onclick="window.scrollTo({top: 0, behavior: 'smooth'}); return false;">
                                Back to Top ↑
                            </a>
                        </div>
                    </div>
                </div>
            </footer>

        </main>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            gsap.registerPlugin(ScrollTrigger);

            const targets = [".intro-viewport", ".action-trigger-zone", ".conclusion-viewport"];

            targets.forEach(selector => {
                const section = document.querySelector(selector);
                if (!section) return;

                const card = section.querySelector('.content-wrapper');
                const heading = card.querySelector('h1');

                // 1. Split Text
                const text = heading.innerText;
                heading.innerHTML = text.split("").map(char =>
                    char === " " ? `<span style="display:inline-block; width: 0.3em;">&nbsp;</span>` : `<span class="char">${char}</span>`
                ).join("");

                // 2. The Timeline
                const tl = gsap.timeline({
                    scrollTrigger: {
                        trigger: section,
                        start: "top 75%",
                        end: "bottom 25%",
                        toggleActions: "play none none reverse"
                    }
                });

                // 3. The "Smooth" Expansion
                tl.fromTo(card,
                    {
                        scale: 0.2,       // Starts very tiny
                        opacity: 0,
                        y: 50,            // Starts slightly lower
                        borderRadius: "10rem" // Starts very rounded
                    },
                    {
                        duration: 1.8,    // Longer duration for smoothness
                        scale: 1,
                        opacity: 1,
                        y: 0,
                        borderRadius: "2rem",
                        ease: "expo.out", // The "Luxury" curve: Fast start, slow finish
                        clearProps: "all"
                    }
                )
                    // 4. Smooth Text Fade-in with Blur
                    .fromTo(heading.querySelectorAll(".char"),
                        {
                            y: 20,
                            opacity: 0,
                            filter: "blur(10px)" // Starts blurry
                        },
                        {
                            duration: 1,
                            y: 0,
                            opacity: 1,
                            filter: "blur(0px)", // Becomes clear
                            stagger: 0.02,
                            ease: "power2.out"
                        }, "-=1.4"); // Start early while card is still expanding
            });
        });
    </script>
    <script>
        // --- 1. TYPED SWAP EFFECT LOGIC ---
        function initTypedSwap() {
            const ATTR = 'data-fls-typed';

            // Helper to split text correctly
            const splitChars = str => {
                return [...str]; // Simple spread for modern browsers
            };

            const parseOpts = root => {
                const def = { duration: 0.45, stagger: 0.03, ease: 'power2.out' };
                const raw = root.getAttribute(ATTR);
                if (raw) {
                    raw.split(';').forEach(p => {
                        const [k, v] = p.split(':').map(s => s.trim());
                        if (k === 'duration') def.duration = parseFloat(v);
                        if (k === 'stagger') def.stagger = parseFloat(v);
                    });
                }
                return def;
            };

            document.querySelectorAll(`[${ATTR}]`).forEach(root => {
                const text = root.textContent.trim();
                root.textContent = '';
                const opt = parseOpts(root);

                // Create Base (Normal) and Alt (Italic/Stroke) layers
                const base = document.createElement('span');
                base.className = 'tsw__base';
                const alt = document.createElement('span');
                alt.className = 'tsw__alt';

                // Inject characters
                splitChars(text).forEach((char, i) => {
                    const s1 = document.createElement('span');
                    s1.className = 'char';
                    s1.textContent = char === ' ' ? '\u00A0' : char;
                    s1.style.transitionDelay = `${i * opt.stagger}s`;

                    const s2 = s1.cloneNode(true);

                    base.appendChild(s1);
                    alt.appendChild(s2);
                });

                root.appendChild(base);
                root.appendChild(alt);
            });
        }

        // --- 2. GSAP FOOTER ANIMATIONS ---
        function initFooterAnimations() {
            // Register ScrollTrigger
            gsap.registerPlugin(ScrollTrigger);

            const footer = document.querySelector('#advanced-footer');
            const ctaText = footer.querySelector('.footer-cta-section');
            const marquee = footer.querySelector('.footer-marquee');
            const gridCols = footer.querySelectorAll('.grid-col');

            // 1. Reveal CTA Section
            gsap.fromTo(ctaText,
                { y: 50, opacity: 0 },
                {
                    y: 0,
                    opacity: 1,
                    duration: 1,
                    ease: "power2.out",
                    scrollTrigger: {
                        trigger: footer,
                        start: "top 75%", // Triggers when top of footer hits 75% of viewport
                    }
                }
            );

            // 2. Expand Marquee width
            gsap.fromTo(marquee,
                { width: "0%", opacity: 0 },
                {
                    width: "100%",
                    opacity: 1,
                    duration: 1.2,
                    ease: "expo.out",
                    delay: 0.2,
                    scrollTrigger: {
                        trigger: footer,
                        start: "top 70%"
                    }
                }
            );

            // 3. Stagger Reveal Grid Columns
            gsap.fromTo(gridCols,
                { y: 30, opacity: 0 },
                {
                    y: 0,
                    opacity: 1,
                    duration: 0.8,
                    stagger: 0.1,
                    delay: 0.4,
                    scrollTrigger: {
                        trigger: footer,
                        start: "top 60%"
                    }
                }
            );
        }

        // Initialize when DOM is ready
        document.addEventListener("DOMContentLoaded", () => {
            initTypedSwap();
            initFooterAnimations();
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            gsap.registerPlugin(ScrollTrigger);

            const lenis = new Lenis();
            lenis.on("scroll", ScrollTrigger.update);
            gsap.ticker.add((time) => {
                lenis.raf(time * 1000);
            });
            gsap.ticker.lagSmoothing(0);

            // =========================================================
            // 1. SETUP AUDIO LOGIC
            // =========================================================
            const typeSound = new Audio('./assets/keyboard-typing-effect-free-393912.mp3');
            typeSound.loop = true; // Loops continuously while scrolling
            typeSound.volume = 0.5; // Adjust volume (0.0 to 1.0)

            let typeSoundTimeout;

            // Function to play sound only when moving
            function manageTypingSound(velocity) {
                // If scroll speed is significant (moving)
                if (Math.abs(velocity) > 5) {
                    if (typeSound.paused) {
                        typeSound.play().catch(e => { }); // Start playing
                    }

                    // Clear any timer that was about to stop the sound
                    clearTimeout(typeSoundTimeout);

                    // Set a new timer to stop sound if motion stops for 150ms
                    typeSoundTimeout = setTimeout(() => {
                        typeSound.pause();
                    }, 150);
                }
            }
            // =========================================================

            // Updated Selector
            const textBlocks = document.querySelectorAll(".kinetic-typography-block p");

            // Updated RGB value for the lighter background highlight (a slate blue tone)
            const wordHighlightRGB = "45, 59, 85";

            const specialKeywords = [
                "designed", "natural", "control", "ideas", "smooth",
                "performance", "creation", "attention", "value",
            ];

            textBlocks.forEach((paragraph) => {
                const textContent = paragraph.textContent;
                const splitWords = textContent.split(/\s+/);
                paragraph.innerHTML = "";

                splitWords.forEach((wordStr) => {
                    if (wordStr.trim()) {
                        const tokenContainer = document.createElement("div");
                        tokenContainer.className = "token-unit";

                        const innerSpan = document.createElement("span");
                        innerSpan.textContent = wordStr;

                        const cleanWord = wordStr.toLowerCase().replace(/[.,!?;:"]/g, "");

                        if (specialKeywords.includes(cleanWord)) {
                            tokenContainer.classList.add("highlight-anchor");
                            innerSpan.classList.add("emphasis-pill", cleanWord);
                        }

                        tokenContainer.appendChild(innerSpan);
                        paragraph.appendChild(tokenContainer);
                    }
                });
            });

            // Updated Selector
            const scrollHosts = document.querySelectorAll(".scroll-sequence-host");

            scrollHosts.forEach((hostEl) => {
                ScrollTrigger.create({
                    trigger: hostEl,
                    pin: hostEl,
                    start: "top top",
                    end: `+=${window.innerHeight * 4}`,
                    pinSpacing: true,
                    onUpdate: (self) => {

                        // --- TRIGGER AUDIO ---
                        manageTypingSound(self.getVelocity());
                        // ---------------------

                        const progress = self.progress;
                        // Updated Selector
                        const allTokens = Array.from(
                            hostEl.querySelectorAll(".kinetic-typography-block .token-unit")
                        );
                        const totalTokens = allTokens.length;

                        allTokens.forEach((token, idx) => {
                            const innerText = token.querySelector("span");

                            if (progress <= 0.7) {
                                // Reveal Phase
                                const progressTarget = 0.7;
                                const revealProgress = Math.min(1, progress / progressTarget);

                                const overlapCount = 15;
                                const animLength = 1 + overlapCount / totalTokens;

                                const startP = idx / totalTokens;
                                const endP = startP + overlapCount / totalTokens;

                                const timeScale = 1 / Math.min(
                                    animLength,
                                    1 + (totalTokens - 1) / totalTokens + overlapCount / totalTokens
                                );

                                const adjStart = startP * timeScale;
                                const adjEnd = endP * timeScale;
                                const duration = adjEnd - adjStart;

                                const tokenProgress = revealProgress <= adjStart
                                    ? 0
                                    : revealProgress >= adjEnd
                                        ? 1
                                        : (revealProgress - adjStart) / duration;

                                token.style.opacity = tokenProgress;

                                // Background Highlight Logic
                                const bgFadeStart = tokenProgress >= 0.9 ? (tokenProgress - 0.9) / 0.1 : 0;
                                const bgOpacity = Math.max(0, 1 - bgFadeStart);
                                token.style.backgroundColor = `rgba(${wordHighlightRGB}, ${bgOpacity})`;

                                // Text Opacity Logic
                                const textThreshold = 0.9;
                                const textRevealP = tokenProgress >= textThreshold
                                    ? (tokenProgress - textThreshold) / (1 - textThreshold)
                                    : 0;

                                innerText.style.opacity = Math.pow(textRevealP, 0.5);

                            } else {
                                // Exit Phase (Reverse/Fade)
                                const reverseProgress = (progress - 0.7) / 0.3;
                                token.style.opacity = 1;
                                const targetOpacity = 1;

                                const revOverlap = 5;
                                const revStart = idx / totalTokens;
                                const revEnd = revStart + revOverlap / totalTokens;

                                const revScale = 1 / Math.max(
                                    1,
                                    (totalTokens - 1) / totalTokens + revOverlap / totalTokens
                                );

                                const revAdjStart = revStart * revScale;
                                const revAdjEnd = revEnd * revScale;
                                const revDur = revAdjEnd - revAdjStart;

                                const revTokenP = reverseProgress <= revAdjStart
                                    ? 0
                                    : reverseProgress >= revAdjEnd
                                        ? 1
                                        : (reverseProgress - revAdjStart) / revDur;

                                if (revTokenP > 0) {
                                    innerText.style.opacity = targetOpacity * (1 - revTokenP);
                                    token.style.backgroundColor = `rgba(${wordHighlightRGB}, ${revTokenP})`;
                                } else {
                                    innerText.style.opacity = targetOpacity;
                                    token.style.backgroundColor = `rgba(${wordHighlightRGB}, 0)`;
                                }
                            }
                        });
                    },
                    // Stop sound immediately if we leave the section (scrolled past it)
                    onLeave: () => { typeSound.pause(); },
                    onLeaveBack: () => { typeSound.pause(); }
                });
            });
        });
    </script>
    <script>
        gsap.registerPlugin(ScrollTrigger);
// --- 0. LOADER ANIMATION (OSMO/WILLEM) ---
        function initLoader() {
            const container = document.querySelector('.loader-screen');
            const loadingLetter = container.querySelectorAll('.willem__letter');
            const box = container.querySelectorAll('.willem-loader__box');
            const growingImage = container.querySelectorAll('.willem__growing-image');
            const headingStart = container.querySelectorAll('.willem__h1-start');
            const headingEnd = container.querySelectorAll('.willem__h1-end');
            const coverImageExtra = container.querySelectorAll('.willem__cover-image-extra');

            // 1. SETUP AUDIO
            const loaderSound = new Audio('./assets/loader.mp3');
            loaderSound.volume = 0.5;

            const tl = gsap.timeline({
                defaults: { ease: 'expo.inOut' },
                onComplete: () => {
                    document.body.classList.remove('is-loading');
                    gsap.to(container, {
                        opacity: 0,
                        display: 'none',
                        duration: 0.5,
                        onComplete: () => ScrollTrigger.refresh()
                    });
                }
            });

            if (loadingLetter) { tl.from(loadingLetter, { yPercent: 100, stagger: 0.025, duration: 1.25 }); }
            if (box.length) { tl.fromTo(box, { width: '0em' }, { width: '1em', duration: 1.25 }, '< 1.25'); }
            if (growingImage.length) { tl.fromTo(growingImage, { width: '0%' }, { width: '100%', duration: 1.25 }, '<'); }
            if (headingStart.length) { tl.fromTo(headingStart, { x: '0em' }, { x: '-0.05em', duration: 1.25 }, '<'); }
            if (headingEnd.length) { tl.fromTo(headingEnd, { x: '0em' }, { x: '0.05em', duration: 1.25 }, '<'); }
            if (coverImageExtra.length) { tl.fromTo(coverImageExtra, { opacity: 1 }, { opacity: 0, duration: 0.05, ease: 'none', stagger: 0.5 }, '-=0.05'); }
            
            // --- 2. SYNCHRONIZED EXPANSION & SOUND ---
            
            // Create a label for the exact moment the expansion should start
            tl.addLabel("zoomEffect", "< 1.25");

            // A. Expand the Image (Visual) - referencing the label
            if (growingImage.length) { 
                tl.to(growingImage, { width: '100vw', height: '100vh', duration: 1.5 }, "zoomEffect"); 
            }
            
            // B. Expand the Box/Text Mask (Visual) - referencing the SAME label
            // This ensures it moves exactly with the image, fixing the text glitch
            if (box.length) { 
                tl.to(box, { width: '100vw', duration: 1.5 }, "zoomEffect"); 
            }

            // C. Play Sound - referencing the label + 0.4s delay
            // It plays slightly later to match the visual "whoosh" of the easing
            tl.call(() => {
                loaderSound.play().catch(e => console.warn("Audio autoplay blocked", e));
            }, null, "zoomEffect+=0.4");
        }
        document.addEventListener('DOMContentLoaded', () => {
            initLoader();
            initCarousel();
            initGlobalPageCursor();
            initFooterCursor();
            initFooterAnimations();
            init3DMarker();
            initGlobalTextAnimations();
            initMobileHeadingEffect();
        });

        // --- GLOBAL PAGE CURSOR ANIMATION (NEW FUNCTION) ---
        function initGlobalPageCursor() {
            const globalCanvas = document.querySelector('#global-cursor-canvas');
            if (!globalCanvas) return;

            const globalCtx = globalCanvas.getContext('2d');
            let globalMouseMoved = false;

            const globalPointer = {
                x: 0.5 * window.innerWidth,
                y: 0.5 * window.innerHeight,
            };

            const params = {
                pointsNumber: 40,
                widthFactor: 0.3,
                mouseThreshold: 0.6,
                spring: 0.4,
                friction: 0.5,
            };

            const trail = new Array(params.pointsNumber);
            for (let i = 0; i < params.pointsNumber; i++) {
                trail[i] = {
                    x: globalPointer.x,
                    y: globalPointer.y,
                    dx: 0,
                    dy: 0,
                };
            }

            window.addEventListener('click', e => {
                updateGlobalMousePosition(e.clientX, e.clientY);
            });
            window.addEventListener('mousemove', e => {
                globalMouseMoved = true;
                updateGlobalMousePosition(e.clientX, e.clientY);
            });
            window.addEventListener('touchmove', e => {
                globalMouseMoved = true;
                updateGlobalMousePosition(e.targetTouches[0].clientX, e.targetTouches[0].clientY);
            });

            function updateGlobalMousePosition(eX, eY) {
                globalPointer.x = eX;
                globalPointer.y = eY;
            }

            function setupGlobalCanvas() {
                globalCanvas.width = window.innerWidth;
                globalCanvas.height = window.innerHeight;
            }

            function updateGlobal(t) {
                // Idle motion when mouse isn't moving
                if (!globalMouseMoved) {
                    globalPointer.x = (0.5 + 0.3 * Math.cos(0.002 * t) * Math.sin(0.005 * t)) * window.innerWidth;
                    globalPointer.y = (0.5 + 0.2 * Math.cos(0.005 * t) + 0.1 * Math.cos(0.01 * t)) * window.innerHeight;
                }

                globalCtx.clearRect(0, 0, globalCanvas.width, globalCanvas.height);

                trail.forEach((p, pIdx) => {
                    const prev = pIdx === 0 ? globalPointer : trail[pIdx - 1];
                    const spring = pIdx === 0 ? 0.4 * params.spring : params.spring;
                    p.dx += (prev.x - p.x) * spring;
                    p.dy += (prev.y - p.y) * spring;
                    p.dx *= params.friction;
                    p.dy *= params.friction;
                    p.x += p.dx;
                    p.y += p.dy;
                });

                globalCtx.lineCap = 'round';
                // Set color to white because we used mix-blend-mode: difference in CSS
                // This makes it look inverted on all backgrounds
                globalCtx.strokeStyle = '#ffffff';

                globalCtx.beginPath();
                globalCtx.moveTo(trail[0].x, trail[0].y);

                for (let i = 1; i < trail.length - 1; i++) {
                    const xc = 0.5 * (trail[i].x + trail[i + 1].x);
                    const yc = 0.5 * (trail[i].y + trail[i + 1].y);
                    globalCtx.quadraticCurveTo(trail[i].x, trail[i].y, xc, yc);
                    globalCtx.lineWidth = params.widthFactor * (params.pointsNumber - i);
                    globalCtx.stroke();
                }
                globalCtx.lineTo(trail[trail.length - 1].x, trail[trail.length - 1].y);
                globalCtx.stroke();

                window.requestAnimationFrame(updateGlobal);
            }

            window.addEventListener('resize', setupGlobalCanvas);

            // Initialize
            setupGlobalCanvas();
            updateGlobal(0);
        }

        // --- 1. URBANIST LOGIC ---
        const integrationSection = document.getElementById("urbanist-integration");
        const panes = gsap.utils.toArray(".pane");
        gsap.set(panes, { width: window.innerWidth });

        const themes = [
            { mainBg: "#b9dcff", subBg: "#f2fbfe", text: "#070f36", title: "#8dc9f4" },
            { mainBg: "#fff58c", subBg: "#fbf1ed", text: "#9c4e23", title: "#9c4e23" },
            { mainBg: "#c4ffb2", subBg: "#f1ffec", text: "#164c3b", title: "#164c3b" }
        ];

        const thresholds = new Array(panes.length).fill(0).map((_, i) => parseFloat(((1 / panes.length) * i).toFixed(2)));
        let activeThemeIndex = 0;

        gsap.to(panes, {
            xPercent: -100 * (panes.length - 1),
            ease: "none",
            scrollTrigger: {
                trigger: integrationSection,
                pin: true,
                scrub: 1,
                start: "top top",
                end: () => "+=" + (window.innerWidth * panes.length * 0.5),
                onUpdate: (self) => {
                    const progress = parseFloat(self.progress.toFixed(2));
                    const themeIndex = thresholds.findLastIndex((threshold) => progress >= threshold);
                    if (themeIndex !== activeThemeIndex && themeIndex >= 0) {
                        activeThemeIndex = themeIndex;
                        updateTheme(themeIndex);
                    }
                }
            }
        });

        function updateTheme(themeIndex) {
            const theme = themes[themeIndex];
            gsap.to(document.documentElement, {
                "--theme-main-bg": theme.mainBg,
                "--theme-sub-bg": theme.subBg,
                "--theme-title": theme.title,
                "--theme-text": theme.text,
                duration: 1,
                ease: "power2.out"
            });
        }

        // --- 2. PERSPECTIVE ZOOM LOGIC ---
        const zoomTimeline = gsap.timeline({
            scrollTrigger: {
                trigger: ".zoom-container",
                start: "top top",
                end: "+=200%",
                scrub: 1,
                pin: true
            }
        });
        zoomTimeline.to(".zoom-item[data-layer='3']", { z: 1000, opacity: 0, ease: "power1.in" }, 0);
        zoomTimeline.to(".zoom-item[data-layer='2']", { z: 600, opacity: 0, ease: "power1.in" }, 0.1);
        zoomTimeline.to(".zoom-item[data-layer='1']", { z: 300, opacity: 0, ease: "power1.in" }, 0.2);
        zoomTimeline.to(".heading-zoom", { z: 200, opacity: 1, scale: 1.5, ease: "power1.out" }, 0);

        // --- 3. TEXT REVEAL LOGIC ---
        const textElement = document.querySelector(".opacity-reveal");
        const textContent = textElement.innerText;
        textElement.innerHTML = '';
        textContent.split('').forEach(char => {
            const span = document.createElement('span');
            span.innerText = char;
            span.style.opacity = "0.1";
            textElement.appendChild(span);
        });
        const chars = textElement.querySelectorAll('span');
        const textTimeline = gsap.timeline({
            scrollTrigger: {
                trigger: ".section-stick",
                start: "center center",
                end: "+=150%",
                pin: true,
                scrub: 0.5
            }
        });
        textTimeline.to(chars, { opacity: 1, stagger: 0.02, duration: 1, ease: "none" })
            .to(textElement, { scale: 1.1, duration: 1, ease: "power2.out" }, "<");

        // --- 4. ALICE SECTION LOGIC ---
        const heroReveal = document.querySelectorAll(".hero-reveal");
        heroReveal.forEach((element) => {
            const heroBox = element.querySelector(".hero-reveal__header");
            const heroHeadings = element.querySelectorAll(".hero-reveal_split_item");
            const contentEl = element.querySelector(".hero-reveal__content");
            if (!heroBox || !contentEl) return;
            const heroBoxHeight = heroBox.offsetHeight;
            const contentHeight = contentEl.offsetHeight;
            const pinDistance = heroBoxHeight > contentHeight ? heroBoxHeight : contentHeight;

            gsap.fromTo(contentEl, { y: "50%" }, {
                y: "0%", ease: "none",
                scrollTrigger: { trigger: element, start: "top top", end: `+=${pinDistance}`, scrub: true }
            });

            const tl = gsap.timeline({ scrollTrigger: { trigger: element, start: "top top", end: `+=${pinDistance}`, scrub: true, pin: true } });
            tl.fromTo(heroBox, { clipPath: "inset(0% 0% 0% 0%)" }, { clipPath: "inset(0% 0% 100% 0%)", duration: 1, ease: "power1.inOut" });

            if (heroHeadings.length >= 2) {
                tl.fromTo(heroHeadings[0], { y: "0%" }, { y: "-30%", ease: "power1.inOut" }, 0);
                tl.fromTo(heroHeadings[1], { y: "0%" }, { y: "30%", ease: "power1.inOut" }, 0);
            }
        });

        function parallaxScrollBySpeed(selector, speed = 1, trigger = ".hero-reveal") {
            const el = document.querySelector(selector);
            const contentEl = document.querySelector(".hero-reveal__content");
            if (!el || !contentEl) return;
            const contentHeight = contentEl.offsetHeight;
            gsap.to(el, {
                yPercent: (speed - 1) * 100, ease: "none",
                scrollTrigger: { trigger: trigger, start: "top top", end: `+=${contentHeight * 2}`, scrub: true }
            });
        }
        parallaxScrollBySpeed(".hero-reveal__parallax-book", 15);
        parallaxScrollBySpeed(".hero-reveal__parallax-clock", 13);
        parallaxScrollBySpeed(".hero-reveal__parallax-alice", 6);
        parallaxScrollBySpeed(".hero-reveal__parallax-kattle", 23);
        parallaxScrollBySpeed(".hero-reveal__parallax-card", 5);

        // --- 5. CAROUSEL SECTION LOGIC (FIXED & STABLE) ---
        function initCarousel() {
            const carouselSection = document.querySelector("#carousel-section");
            const slides = gsap.utils.toArray(".slide"); // Get all pre-rendered slides

            // Create a timeline that spans the pinning duration
            const tl = gsap.timeline({
                scrollTrigger: {
                    trigger: carouselSection,
                    start: "top top",
                    end: "+=4000",
                    scrub: 1, // Smooth scrubbing, user can reverse easily
                    pin: true
                }
            });
            // 1. Reveal Slide 2
            tl.to("#slide-2", {
                clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                duration: 1,
                ease: "none" // Linear ease for direct mapping to scroll
            });

            // 2. Reveal Slide 3
            tl.to("#slide-3", {
                clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                duration: 1,
                ease: "none"
            });

            // 3. Reveal Slide 4
            tl.to("#slide-4", {
                clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                duration: 1,
                ease: "none"
            });

            // Add a small buffer at the end so the user sees the last slide before unpinning
            tl.to({}, { duration: 0.5 });
        }

        // --- 6. FOOTER CURSOR LOGIC ---
        function initFooterCursor() {
            const canvas = document.querySelector('#footer-canvas');
            const footer = document.querySelector('#advanced-footer');
            if (!canvas || !footer) return;

            const ctx = canvas.getContext('2d');
            let mouseMoved = false;

            const pointer = { x: 0.5 * window.innerWidth, y: 0.5 * window.innerHeight };
            const params = {
                pointsNumber: 40,
                widthFactor: 0.3,
                mouseThreshold: 0.6,
                spring: 0.4,
                friction: 0.5,
            };

            const trail = new Array(params.pointsNumber);
            for (let i = 0; i < params.pointsNumber; i++) {
                trail[i] = { x: pointer.x, y: pointer.y, dx: 0, dy: 0 };
            }

            footer.addEventListener('mousemove', e => {
                mouseMoved = true;
                const rect = footer.getBoundingClientRect();
                pointer.x = e.clientX - rect.left;
                pointer.y = e.clientY - rect.top;
            });

            // Also handle global window resizing
            window.addEventListener('resize', setupCanvas);

            function setupCanvas() {
                const rect = footer.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
            }

            function update(t) {
                // If mouse hasn't moved yet, create a gentle idle animation
                if (!mouseMoved) {
                    pointer.x = (0.5 + 0.3 * Math.cos(0.002 * t) * Math.sin(0.005 * t)) * canvas.width;
                    pointer.y = (0.5 + 0.2 * Math.cos(0.005 * t) + 0.1 * Math.cos(0.01 * t)) * canvas.height;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                trail.forEach((p, pIdx) => {
                    const prev = pIdx === 0 ? pointer : trail[pIdx - 1];
                    const spring = pIdx === 0 ? 0.4 * params.spring : params.spring;
                    p.dx += (prev.x - p.x) * spring;
                    p.dy += (prev.y - p.y) * spring;
                    p.dx *= params.friction;
                    p.dy *= params.friction;
                    p.x += p.dx;
                    p.y += p.dy;
                });

                ctx.lineCap = 'round';
                ctx.strokeStyle = '#ffffff'; // White trail on black footer
                ctx.beginPath();
                ctx.moveTo(trail[0].x, trail[0].y);

                for (let i = 1; i < trail.length - 1; i++) {
                    const xc = 0.5 * (trail[i].x + trail[i + 1].x);
                    const yc = 0.5 * (trail[i].y + trail[i + 1].y);
                    ctx.quadraticCurveTo(trail[i].x, trail[i].y, xc, yc);
                    ctx.lineWidth = params.widthFactor * (params.pointsNumber - i);
                    ctx.stroke();
                }
                ctx.lineTo(trail[trail.length - 1].x, trail[trail.length - 1].y);
                ctx.stroke();

                window.requestAnimationFrame(update);
            }

            setupCanvas();
            update(0);
        }

        // --- 7. FOOTER REVEAL ANIMATIONS ---
        function initFooterAnimations() {
            const footer = document.querySelector('#advanced-footer');
            const bigText = footer.querySelector('.footer-big-text');
            const links = footer.querySelectorAll('.footer-links a');
            const bottom = footer.querySelector('.footer-bottom');

            // Animate Big Text
            gsap.to(bigText, {
                opacity: 1,
                y: 0,
                duration: 1.5,
                ease: "power3.out",
                scrollTrigger: {
                    trigger: footer,
                    start: "top 75%",
                }
            });

            // Animate Links Stagger
            gsap.to(links, {
                y: 0,
                duration: 1,
                stagger: 0.1,
                ease: "power3.out",
                scrollTrigger: {
                    trigger: footer,
                    start: "top 75%",
                }
            });

            // Animate Bottom Bar
            gsap.to(bottom, {
                opacity: 1,
                duration: 1,
                delay: 0.5,
                scrollTrigger: {
                    trigger: footer,
                    start: "top 80%",
                }
            });
        }
    </script>
    <script>function init3DMarker() {
            const container = document.getElementById('threejs-marker-container');
            if (!container) return;

            // --- 1. SETUP THREE.JS SCENE ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 28;

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 10, 20);
            dirLight.castShadow = true;
            scene.add(dirLight);
            const spotLight = new THREE.SpotLight(0xffffff, 0.8);
            spotLight.position.set(-10, 0, 10);
            scene.add(spotLight);

            // --- 2. BUILD THE MARKER ---
            // Materials
            function createLabelTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 1024; canvas.height = 512;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#fcfcfc'; ctx.fillRect(0, 0, 1024, 512);
                ctx.fillStyle = '#000000'; ctx.font = '900 130px Helvetica, Arial'; ctx.textAlign = 'center'; ctx.fillText('WHITE BOARD', 512, 250);
                ctx.fillStyle = '#d91c24'; ctx.fillRect(720, 170, 250, 90);
                ctx.fillStyle = '#ffffff'; ctx.font = 'bold 60px Helvetica, Arial'; ctx.fillText('Camlin', 845, 235);
                return new THREE.CanvasTexture(canvas);
            }
            const labelTex = createLabelTexture();
            labelTex.wrapS = THREE.RepeatWrapping; labelTex.repeat.set(-1, 1); labelTex.offset.set(0.75, 0);

            const matBody = new THREE.MeshStandardMaterial({ map: labelTex, roughness: 0.3, metalness: 0.05 });
            const matRed = new THREE.MeshStandardMaterial({ color: 0xd91c24, roughness: 0.2, metalness: 0.1 });
            const matNib = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
            const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });

            // Groups: markerSystem (GSAP moves this) -> floatGroup (Math moves this) -> body/cap
            const markerSystem = new THREE.Group();
            scene.add(markerSystem);
            const floatGroup = new THREE.Group();
            markerSystem.add(floatGroup);

            const r = 0.8; const len = 8.0;

            // Body
            const bodyGroup = new THREE.Group();
            floatGroup.add(bodyGroup);
            const cyl = new THREE.Mesh(new THREE.CylinderGeometry(r, r, len, 64), matBody);
            cyl.rotation.y = Math.PI; cyl.castShadow = true; bodyGroup.add(cyl);
            const plug = new THREE.Mesh(new THREE.CylinderGeometry(r, r, 0.5, 64), matRed);
            plug.position.y = (len / 2) + 0.25; bodyGroup.add(plug);
            const taper = new THREE.Mesh(new THREE.CylinderGeometry(r, 0.45, 1.8, 64), matWhite);
            taper.position.y = -(len / 2) - 0.9; bodyGroup.add(taper);
            // Replaced sharp Cone with blunt Cylinder for smoother look
            const nib = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.3, 0.9, 32), matNib);
            nib.position.y = -(len / 2) - 2.1; nib.rotation.z = Math.PI; bodyGroup.add(nib);

            // Cap
            const capGroup = new THREE.Group();
            floatGroup.add(capGroup);
            const capLen = 3.8; const capR = r + 0.12;
            const capShell = new THREE.Mesh(new THREE.CylinderGeometry(capR - 0.05, capR, capLen, 64), matRed);
            capShell.geometry.translate(0, -capLen / 2, 0); capShell.castShadow = true; capGroup.add(capShell);
            const ring = new THREE.Mesh(new THREE.CylinderGeometry(capR + 0.1, capR + 0.1, 0.6, 64), matRed);
            ring.position.y = -0.5; capGroup.add(ring);
            const clip = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2.8, 0.5), matRed);
            clip.position.set(capR + 0.05, -2.0, 0); capGroup.add(clip);

            // Initial Layout
            const bodyStartY = 12.0; const capStartY = -14.0;
            const bodyClosedY = 0; const capClosedY = -3.9;
            bodyGroup.position.y = bodyStartY; capGroup.position.y = capStartY;

            // --- 3. ANIMATION CONFIGURATION ---
            // This is where you define the "Dance" for each section
            const isMobile = window.innerWidth < 768;

            const sectionStates = [
                {
                    // STATE 0: HERO (Initial)
                    // Cap Closing Animation happens here separately
                    trigger: ".hero",
                    start: "top top", end: "bottom top",
                    desktop: { x: 6.5, y: 2, z: 0, rotX: 0, rotY: 0, rotZ: -0.78, scale: 1 },
                    mobile: { x: 2.0, y: 1.5, z: 0, rotX: 0, rotY: 0, rotZ: -0.78, scale: 0.4 }
                },
                {
                    // STATE 1: URBANIST (Move to Left Side, Rotate 90 deg)
                    trigger: "#urbanist-integration",
                    start: "top bottom", end: "center center",
                    desktop: { x: -9, y: 0, z: 0, rotX: 0.2, rotY: Math.PI, rotZ: Math.PI - 0.5, scale: 0.9 },
                    mobile: { x: -2, y: -4, z: 0, rotX: 0.2, rotY: Math.PI, rotZ: Math.PI - 0.5, scale: 0.35 }
                },
                {
                    // STATE 2: GRID SCROLL (Move Top Right, Horizontal)
                    trigger: "#grid-scroll-wrapper",
                    start: "top bottom", end: "center center",
                    desktop: { x: 8, y: 4, z: -2, rotX: 0, rotY: Math.PI * 2, rotZ: -1.57, scale: 0.8 },
                    mobile: { x: 2, y: 5, z: -2, rotX: 0, rotY: Math.PI * 2, rotZ: -1.57, scale: 0.35 }
                },
                {
                    // STATE 3: ALICE SECTION (Move Bottom Left, Diagonal Flip)
                    trigger: "#alice-wrapper",
                    start: "top bottom", end: "center center",
                    desktop: { x: -8, y: -3, z: 2, rotX: 0.5, rotY: Math.PI * 3, rotZ: Math.PI - 0.7, scale: 0.9 },
                    mobile: { x: -2, y: -2, z: 2, rotX: 0.5, rotY: Math.PI * 3, rotZ: Math.PI - 0.7, scale: 0.35 }
                },
                {
                    // STATE 4: TEXT/CAPABILITIES (Center Right, Vertical)
                    trigger: ".capabilities-segment",
                    start: "top bottom", end: "center center",
                    desktop: { x: 9, y: 0, z: 0, rotX: 0, rotY: Math.PI * 3.5, rotZ: Math.PI, scale: 0.9 },
                    mobile: { x: 2.5, y: 0, z: 0, rotX: 0, rotY: Math.PI * 3.5, rotZ: Math.PI, scale: 0.35 }
                }
            ];

            // --- 4. APPLY INITIAL POSITION ---
            const startState = isMobile ? sectionStates[0].mobile : sectionStates[0].desktop;
            markerSystem.position.set(startState.x, startState.y, startState.z);
            markerSystem.rotation.set(startState.rotX, startState.rotY, startState.rotZ);
            markerSystem.scale.set(startState.scale, startState.scale, startState.scale);


            // --- 5. CREATE SCROLL TRIGGERS ---

            // 1. SETUP AUDIO (Add this new part)
            const capSound = new Audio('./assets/closeSound.mpeg');
            capSound.volume = 0.6; // Adjust volume if needed

            // A. SPECIAL HERO CAP ANIMATION (Closing the marker)
            const heroTl = gsap.timeline({
                scrollTrigger: {
                    trigger: ".hero",
                    start: "top top",
                    end: "80% top",
                    scrub: 1,
                    // NEW: Play sound when scrolling down finishes the "closing" action
                    onLeave: () => {
                        capSound.currentTime = 0; // Reset sound to start
                        capSound.play().catch(e => console.log("Audio waiting for interaction"));
                    },
                    // Optional: If you want it to click again if they scroll up and then back down
                    onEnterBack: () => {
                        // Resets logic if needed, but usually sound only plays on close
                    }
                }
            });

            // ... (Rest of your existing code: heroTl.to bodyGroup, capGroup etc) ...
            heroTl.to(bodyGroup.position, { y: bodyClosedY, ease: "power2.out" }, 0);
            heroTl.to(capGroup.position, { y: capClosedY, ease: "power2.out" }, 0);


            // B. MOVEMENT ANIMATIONS (Connecting Sections)
            // We skip index 0 because that's our starting point
            for (let i = 1; i < sectionStates.length; i++) {
                const prevState = sectionStates[i - 1];
                const currState = sectionStates[i];

                const prevCfg = isMobile ? prevState.mobile : prevState.desktop;
                const currCfg = isMobile ? currState.mobile : currState.desktop;

                // Create a timeline for this section's transition
                const tl = gsap.timeline({
                    scrollTrigger: {
                        trigger: currState.trigger,
                        start: currState.start,
                        end: currState.end,
                        scrub: isMobile ? 1 : 1.5, // Faster scrub for mobile responsiveness
                    }
                });

                // Position
                tl.fromTo(markerSystem.position,
                    { x: prevCfg.x, y: prevCfg.y, z: prevCfg.z },
                    { x: currCfg.x, y: currCfg.y, z: currCfg.z, ease: "power1.inOut", immediateRender: false },
                    0
                );

                // Rotation
                tl.fromTo(markerSystem.rotation,
                    { x: prevCfg.rotX, y: prevCfg.rotY, z: prevCfg.rotZ },
                    { x: currCfg.rotX, y: currCfg.rotY, z: currCfg.rotZ, ease: "power1.inOut", immediateRender: false },
                    0
                );

                // Scale
                tl.fromTo(markerSystem.scale,
                    { x: prevCfg.scale, y: prevCfg.scale, z: prevCfg.scale },
                    { x: currCfg.scale, y: currCfg.scale, z: currCfg.scale, ease: "power1.inOut", immediateRender: false },
                    0
                );
            }


            // C. HIDE MARKER AT PRIME INK SECTION
            gsap.to(container, {
                opacity: 0,
                duration: 0.5,
                ease: "power2.inOut",
                scrollTrigger: {
                    trigger: ".hero-reveal",
                    start: "top center",
                    toggleActions: "play none none reverse"
                }
            });


            // --- 6. RENDER LOOP (With Floating Motion) ---
            function animate() {
                requestAnimationFrame(animate);
                const t = Date.now() * 0.001;

                // Independent Idle Animation (Sine Waves)
                // This happens on TOP of the GSAP scrolling movement
                floatGroup.position.y = Math.sin(t * 1.5) * 0.3; // Bob up/down
                floatGroup.rotation.x = Math.sin(t * 1.2) * 0.1; // Gentle tilt
                floatGroup.rotation.z = Math.cos(t * 0.9) * 0.1; // Gentle sway

                renderer.render(scene, camera);
            }
            animate();


            // --- 7. RESIZE HANDLER ---
            function onResize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
                // Note: We don't reset positions here to avoid conflict with ScrollTrigger
                // A full refresh is better for responsive layout changes
            }
            window.addEventListener('resize', onResize);
        }</script>
    <script>
        function initGlobalTextAnimations() {
            const textElements = document.querySelectorAll("h1, h2, h3, h4, p, li, span.footer-big-text");

            textElements.forEach((element) => {
                if (element.closest('.loader-screen')) return;
                if (element.closest('.hero__title')) return;
                if (element.closest('.kinetic-typography-block')) return;
                if (element.closest('#panes-container')) return;

                gsap.fromTo(element,
                    {
                        y: 50,
                        opacity: 0,
                        clipPath: "polygon(0 0, 100% 0, 100% 0, 0 0)"
                    },
                    {
                        y: 0,
                        opacity: 1,
                        clipPath: "polygon(0 0, 100% 0, 100% 100%, 0 100%)",
                        duration: 1,
                        ease: "power3.out",
                        scrollTrigger: {
                            trigger: element,
                            start: "top 90%",
                            toggleActions: "play none none reverse"
                        }
                    }
                );
            });
        }
    </script>
    <script>
        function initMobileHeadingEffect() {
            ScrollTrigger.matchMedia({

                // Target Mobile Screens (max-width 768px)
                "(max-width: 768px)": function () {

                    gsap.to(".intro__heading", {
                        y: 420,
                        opacity: 1,
                        ease: "none",
                        scrollTrigger: {
                            trigger: ".intro",
                            start: "top 40%",
                            end: "bottom top",
                            scrub: 1
                        }
                    });

                }
            });
        }
    </script>
 <script>
        const canvas = document.getElementById("hero-canvas");
        const ctx = canvas.getContext("2d");
        let lastPos = null;

        // --- FIX 1: Allow default touch actions so users can scroll ---
        canvas.style.touchAction = "auto"; 

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + "px";
            canvas.style.height = window.innerHeight + "px";
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
            ctx.globalCompositeOperation = "source-over";
            ctx.fillStyle = "#fff";
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
            ctx.globalCompositeOperation = "destination-out";
            ctx.lineCap = "round";
            ctx.lineWidth = 70;
            ctx.strokeStyle = "rgba(0,0,0,1)";
        }

        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);
        window.addEventListener("load", resizeCanvas);
        setTimeout(resizeCanvas, 500);

        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function draw(e) {
            // --- FIX 2: Removed e.preventDefault() so page can scroll ---
            // If you want to disable scratching ONLY on mobile to make scrolling easier,
            // you can uncomment this line:
            // if (window.innerWidth < 768) return; 

            const { x, y } = getCoords(e);
            ctx.beginPath();
            if (lastPos) {
                ctx.moveTo(lastPos.x, lastPos.y);
                ctx.lineTo(x, y);
                ctx.stroke();
            }
            lastPos = { x, y };
        }

        function handleStart(e) {
            // --- FIX 3: Removed e.preventDefault() here too ---
            const { x, y } = getCoords(e);
            lastPos = { x, y };
        }

        function handleEnd() {
            lastPos = null;
        }

        // Mouse Events
        canvas.addEventListener("mousemove", draw);
        canvas.addEventListener("mouseleave", handleEnd);

        // Touch Events
        // --- FIX 4: Changed passive to true (allows scrolling while touching) ---
        canvas.addEventListener("touchstart", handleStart, { passive: true });
        canvas.addEventListener("touchmove", draw, { passive: true });
        canvas.addEventListener("touchend", handleEnd);

        // --- Custom Cursor Logic (Kept unchanged) ---
        const cursor = document.querySelector(".custom-cursor");
        if(cursor) { // Added safety check
            const interactiveSelector = ["a[href]", "button", "canvas", '[role="button"]', "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", '[data-cursor="interactive"]'].join(",");
            const stickyItems = document.querySelectorAll(".sticky-item");
            let isSticky = false;
            
            function isPureBlack(e) { if (!e || !e.startsWith("rgb")) return !1; const [t, s, o] = e.match(/\d+/g).map(Number); return t === 0 && s === 0 && o === 0 }
            function isBackgroundBlack(e) { for (; e && e !== document.body;) { const t = getComputedStyle(e).backgroundColor; if (t !== "rgba(0, 0, 0, 0)" && !isPureBlack(t)) return !1; e = e.parentElement } return !0 }
            function getAllElementsAt(e, t) { const s = [], o = []; let l; for (; (l = document.elementFromPoint(e, t)) && !s.includes(l);)s.push(l), o.push({ el: l, pe: l.style.pointerEvents }), l.style.pointerEvents = "none"; return o.forEach(({ el: n, pe: a }) => n.style.pointerEvents = a), s }
            
            let rAF = null;
            function handlePointerMove(e) { rAF || (rAF = requestAnimationFrame(() => { isSticky || (cursor.style.transform = `translate(${e.clientX}px, ${e.clientY}px) translate(-50%, -50%)`); const s = getAllElementsAt(e.clientX, e.clientY).every(isBackgroundBlack); cursor.classList.toggle("red", s); const o = document.elementFromPoint(e.clientX, e.clientY), l = o && o.closest(interactiveSelector); cursor.classList.toggle("--interactive", !!l), rAF = null })) }
            document.addEventListener("mousemove", handlePointerMove);
            stickyItems.forEach(e => { e.addEventListener("mouseenter", () => { const t = e.getBoundingClientRect(), s = t.left + t.width / 2, o = t.top + t.height / 2; cursor.classList.add("--sticky"), cursor.style.transform = `translate(${s}px, ${o}px) translate(-50%, -50%)`, isSticky = !0 }), e.addEventListener("mouseleave", () => { cursor.classList.remove("--sticky"), isSticky = !1 }) });
            document.addEventListener("mouseleave", () => cursor.style.opacity = "0");
            document.addEventListener("mouseenter", () => cursor.style.opacity = "1");
        }
    </script>
</body>

</html>