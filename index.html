<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARKER</title>
    <!-- Fonts -->
    <link rel="preload" href="./assets/fonts/Presicav.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="./assets/fonts/Calibre-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="./assets/fonts/Arial.woff2" as="font" type="font/woff2" crossorigin="anonymous">

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://api.fontshare.com/v2/css?f[]=neue-montreal@500&display=swap" rel="stylesheet">

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    <script src="https://unpkg.com/lenis@1.1.20/dist/lenis.min.js"></script>
    <script type="module" crossorigin src="./js/index.min.js?v=1754734869502"></script>
    <link rel="stylesheet" crossorigin href="./css/index.min.css?v=1754734869502">
    <link rel="stylesheet" href="./style.css">

</head>

<body class="is-loading">

    <canvas id="global-cursor-canvas"></canvas>

    <!-- <model-viewer id="marker-3d-canvas" src="office-decor-organiser-pen/source/office_decor_organiser_pen (1).glb"
        alt="3D Marker Pen" auto-rotate camera-controls disable-zoom shadow-intensity="1"
        style="width: 80vh; height: 80vh;">
    </model-viewer> -->
    <div id="threejs-marker-container"></div>
      <section class="loader-screen">
        <div class="loader-content">
            <div class="willem__h1">
                <div class="willem__h1-start">
                    <span class="willem__letter">M</span>
                    <span class="willem__letter">A</span>
                    <span class="willem__letter">R</span>
                </div>
                <div class="willem-loader__box">
                    <div class="willem-loader__box-inner">
                        <div class="willem__growing-image">
                            <div class="willem__growing-image-wrap">
                                <img class="willem__cover-image-extra is--1" src="./assets/marker1.jpg" loading="lazy"
                                    alt="">
                                <img class="willem__cover-image-extra is--2" src="./assets/marker2.jpeg" loading="lazy"
                                    alt="">
                                <img class="willem__cover-image-extra is--3" src="./assets/marker3.webp" loading="lazy"
                                    alt="">
                                <img class="willem__cover-image" src='./assets/whitee.png' loading="lazy" alt="">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="willem__h1-end">
                    <span class="willem__letter">K</span>
                    <span class="willem__letter">E</span>
                    <span class="willem__letter">R</span>
                </div>
            </div>
        </div>
    </section>

    <div class="wrapper">
        <header class="header fade" data-fls-header="" data-fls-header-scroll="" data-fls-header-scroll-show="">
            <div class="header__container">
                <div class="header__menu menu">
                    <h1 class="logo">
                        <a href="#">MARKER</a>
                    </h1>
                </div>
            </div>
        </header>

        <main class="page page--home">

            <section class="hero">
                <video class="hero__video" src="./files/banner-hero.mov" autoplay muted loop playsinline=""></video>
                <canvas class="hero__canvas" id="hero-canvas"></canvas>
                <h1 class="hero__title" data-fls-watcher="" data-fls-watcher-once="">
                    <span>MARKER</span>
                </h1>
            </section>
            <section id="urbanist-integration">
                <svg class="urbanist-bg" width="100%" viewBox="0 0 1920 1300" fill="none"
                    xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none">
                    <rect width="1920" height="1300" fill="url(#gradient)"></rect>
                    <defs>
                        <linearGradient id="gradient" x1="1300.54" y1="201.621" x2="959.727" y2="841.863"
                            gradientUnits="userSpaceOnUse">
                            <stop offset="0.15" stop-color="var(--theme-sub-bg)" stop-opacity="1"></stop>
                            <stop offset="0.85" stop-color="var(--theme-main-bg)"></stop>
                        </linearGradient>
                    </defs>
                </svg>

                <div class="content-layer">
                    <h1>Marker</h1>
                    <p class="desc-1">
                        The Marker font captures the spontaneous energy and look of a broad-tipped permanent
                        marker, offering a bold and authentic hand-drawn aesthetic for digital interfaces.
                    </p>
                    <p class="desc-2">
                        Characterized by its irregular edges, organic flow, and varying stroke weights, it
                        breaks away from rigid digital grids to deliver a raw, human touch.
                    </p>
                    <p class="desc-3">
                        Ideal for impactful headlines and creative overlays, this typeface transforms
                        standard typography into expressive, attention-grabbing visual statements.
                    </p>
                </div>

                <div id="panes-container">
                    <div class="pane">
                        <img class="urbanist-floating-img" src="./assets/blue.png" alt="Marker design inspiration 1">
                    </div>
                    <div class="pane">
                        <img class="urbanist-floating-img" src="./assets/orange.png" alt="Marker design inspiration 2">
                    </div>
                    <div class="pane">
                        <img class="urbanist-floating-img" src="./assets/green.png" alt="Marker design inspiration 3">
                    </div>
                </div>
            </section>
            <section id="grid-scroll-wrapper">
                <section style="margin-bottom: -200px;" class="section-stick">
                    <p class="opacity-reveal reveal-text-style">
                        If you’re bold, a single marker stroke will break the grid, steal the show, and change
                        everything.
                    </p>
                </section>
            </section>
            <div id="alice-wrapper">
                <section class="intro">
                    <h1 class="intro__heading">The Permanent Marker's<br />Bold Revolution</h1>
                </section>
                <section class="content">
                    <article class="article">
                        <h4><b>Red Marker (Highest Priority)</b></h4>
                        <p>
                            RED is the most attention-grabbing marker colour. It represents urgency, danger, and high
                            importance,
                            making it ideal for warnings and critical highlights.
                        </p>
                        <p class="mobile-hidden">
                            Its strong visual impact ensures immediate focus, so it is used carefully and with clear
                            intention.
                        </p>

                        <h4><b>Black Marker</b></h4>
                        <p>
                            BLACK symbolizes clarity and authority. It is widely used for writing, outlining, and clear
                            communication due to its high readability.
                        </p>
                        <p class="mobile-hidden">
                            Because of its professional appearance, black is preferred for formal and final work.
                        </p>

                        <h4><b>Blue Marker</b></h4>
                        <p>
                            BLUE represents trust and calmness. It is commonly used for general writing and explanations
                            without creating visual stress.
                        </p>
                        <p class="mobile-hidden">
                            This colour is suitable for notes and planning where balance and clarity are needed.
                        </p>

                        <h4><b>Green Marker (Lowest Priority)</b></h4>
                        <p>
                            GREEN stands for positivity and approval. It is often used to show correctness or progress.
                        </p>
                        <p class="mobile-hidden">
                            With lower urgency, green works best for supportive and secondary highlights.
                        </p>
                    </article>
                </section>
                <div class="hero-reveal-wrapper">
                    <section class="hero-reveal">
                        <article>
                            <header class="hero-reveal__header">
                                <div class="hero-reveal_split">
                                    <div class="hero-reveal_split_item">
                                        <p>PERFECT INK</p>
                                    </div>
                                    <div class="hero-reveal_split_item" aria-hidden="true">
                                        <p aria-hidden="true">PERFECT INK</p>
                                    </div>
                                </div>
                            </header>

                            <div class="hero-reveal__content">
                                <div class="hero-reveal__content-inner">
                                    <div class="hero-reveal__parallax">
                                        <img src="https://assets.codepen.io/204808/alice-falling-1.png" alt="Alice"
                                            class="hero-reveal__parallax-alice" />
                                        <img width="150" src="https://assets.codepen.io/204808/alice-falling-clock.png"
                                            alt="Clock" class="hero-reveal__parallax-clock" />
                                        <img width="100" src="https://assets.codepen.io/204808/alice-falling-book.png"
                                            alt="Book" class="hero-reveal__parallax-book" />
                                        <img width="50" src="https://assets.codepen.io/204808/alice-falling-kattle.png"
                                            alt="Kattle" class="hero-reveal__parallax-kattle" />
                                        <img width="330" src="https://assets.codepen.io/204808/alice-falling-card.png"
                                            alt="Card" class="hero-reveal__parallax-card" />
                                    </div>

                                    <div class="hero-reveal__content-p">
                                        <p>
                                            <B>The ink of the marker</B> flowed with confidence, bold and consistent,
                                            leaving
                                            behind a stroke that felt
                                            <B>permanent and intentional</B>. It dried quickly on the surface, resisting
                                            smudges, while the pigment
                                            settled deep into the material, giving the line its strong and lasting
                                            presence.
                                        </p>
                                        <p class="mobile-hidden">
                                            As the marker moved, the ink revealed its character — rich in color,
                                            balanced in density, and smooth
                                            in motion. Each stroke carried clarity, allowing ideas to take shape without
                                            interruption or loss
                                            of control.
                                        </p>
                                        <p>
                                            Unlike ordinary pens, marker ink is designed to command attention. Its
                                            formulation blends pigments
                                            and solvents carefully, ensuring even coverage while maintaining durability
                                            across different
                                            surfaces and textures.
                                        </p>
                                        <p class="mobile-hidden">
                                            <B>“This is not just ink,”</B> the creator realized, <B>“it is expression
                                                itself.”</B>
                                            With every line drawn, the
                                            marker transformed thought into form, leaving marks that spoke with
                                            strength, precision, and purpose.
                                        </p>
                                    </div>

                                </div>
                            </div>
                        </article>
                    </section>
                </div>
                <section class="content">
                    <article class="article">
                        <h4><b>Impact</b></h4>
                        <p>
                            Marker ink is designed to produce strong, high-contrast lines that remain clearly visible on
                            a
                            variety of surfaces. Its fast-drying nature reduces smudging and allows users to work
                            quickly
                            without interruption, especially in professional and creative environments.
                        </p>
                        <p class="mobile-hidden">
                            The consistent flow of marker ink helps define shapes and outlines with precision. Once
                            applied,
                            the ink penetrates the surface fibers, making corrections difficult and encouraging
                            confident,
                            deliberate strokes.
                        </p>
                        <p class="mobile-hidden">
                            Due to its high pigment concentration, marker ink resists fading over time. This makes it
                            suitable
                            for signage, illustrations, and notes that require long-lasting visibility.
                        </p>

                        <h4><b>Legacy</b></h4>
                        <p>
                            Markers have become essential tools across education, design, and industry. Their
                            reliability and
                            ease of use have made them a standard choice for communication, planning, and visual
                            expression.
                        </p>
                        <p class="mobile-hidden">
                            Over time, advancements in ink formulation—such as alcohol-based and water-based inks—have
                            improved
                            durability, color richness, and environmental safety, ensuring markers remain relevant and
                            widely
                            used.
                        </p>
                    </article>
                </section>
            </div>
            <section class="viewport-section intro-viewport">
                <div class="content-wrapper">
                    <h1>A creative marker built for clarity, control, and expression.</h1>
                </div>
            </section>
            <section class="viewport-section narrative-segment scroll-sequence-host">
                <div class="content-wrapper">
                    <div class="kinetic-typography-block">
                        <p>
                            Marker is designed as a focused tool for creators who value precision
                            and intention. Every stroke carries meaning, and every interaction is
                            crafted to feel natural, responsive, and purposeful.
                        </p>
                        <p>
                            More than a simple tool, Marker adapts to your workflow. It gives you
                            control over form, movement, and structure while staying effortless
                            to use. From quick ideas to refined details, Marker supports the way
                            you think and create.
                        </p>
                    </div>
                </div>
            </section>
            <section class="viewport-section action-trigger-zone">
                <div class="content-wrapper">
                    <h1>Create with confidence using Marker’s powerful tools.</h1>
                </div>
            </section>
            <section class="viewport-section capabilities-segment scroll-sequence-host">
                <div class="content-wrapper">
                    <div class="kinetic-typography-block">
                        <p>
                            Marker offers smooth interactions, adaptive precision, and intelligent
                            responsiveness in every feature. Whether you are highlighting ideas,
                            shaping concepts, or guiding attention, Marker reacts instantly and
                            accurately to your intent.
                        </p>
                        <p>
                            With optimized performance, flexible controls, and real-time feedback,
                            Marker transforms simple actions into expressive outcomes. It is built
                            to stay out of your way while enhancing every moment of creation.
                        </p>
                    </div>
                </div>
            </section>
            <section class="viewport-section conclusion-viewport">
                <div class="content-wrapper">
                    <h1>Marker empowers creators to define ideas with purpose.</h1>
                </div>
            </section>

            <footer id="advanced-footer">
                <canvas id="footer-canvas"></canvas>
                <div class="footer-content">
                    <div class="footer-left">
                        <h2 class="footer-big-text">Marker<br>Digital.</h2>
                        <div style="font-size: 0.9rem; opacity: 0.6; margin-top: auto;">© 2025 All Rights Reserved.
                        </div>
                    </div>
                    <div class="footer-right">
                        <div class="footer-links">
                            <ul>
                                <li><a href="#">Work</a></li>
                                <li><a href="#">Studio</a></li>
                                <li><a href="#">News</a></li>
                            </ul>
                            <ul>
                                <li><a href="#">Instagram</a></li>
                                <li><a href="#">Twitter</a></li>
                                <li><a href="#">LinkedIn</a></li>
                            </ul>
                        </div>
                        <div class="footer-bottom">
                            <span>Kochi, India</span>
                            <span>Scroll to top ↑</span>
                        </div>
                    </div>
                </div>
            </footer>

        </main>
    </div>

    <script type="module">
        import { animate, scroll, cubicBezier } from 'https://cdn.jsdelivr.net/npm/motion@11.11.16/+esm';

        window.addEventListener('load', () => {
            const image = document.querySelector('.gs-scaler img');
            const track = document.querySelector('.gs-track');
            const layers = document.querySelectorAll('.gs-grid > .gs-layer');

            if (!image || !track) return;

            // Measure sizes
            const naturalWidth = image.offsetWidth;
            const naturalHeight = image.offsetHeight;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // 1. Animate the center image (Shrink from full screen to grid size)
            scroll(
                animate(image, {
                    width: [`${viewportWidth}px`, `${naturalWidth}px`],
                    height: [`${viewportHeight}px`, `${naturalHeight}px`],
                    borderRadius: ['0px', '8px']
                }, {
                    width: { easing: cubicBezier(0.65, 0, 0.35, 1) },
                    height: { easing: cubicBezier(0.42, 0, 0.58, 1) },
                    borderRadius: { easing: cubicBezier(0.65, 0, 0.35, 1) }
                }),
                {
                    target: track,
                    offset: ['start start', '80% end']
                }
            );

            // 2. Animate the surrounding layers (Fade in and scale up)
            const scaleEasings = [
                cubicBezier(0.42, 0, 0.58, 1), // Layer 1
                cubicBezier(0.76, 0, 0.24, 1), // Layer 2
                cubicBezier(0.87, 0, 0.13, 1)  // Layer 3
            ];

            layers.forEach((layer, index) => {
                // Stagger the end offsets slightly
                const endOffset = `${0.9 - (index * 0.05)} end`;

                // Opacity Animation
                scroll(
                    animate(layer, { opacity: [0, 0, 1] }, {
                        offset: [0, 0.5, 1],
                        easing: cubicBezier(0.61, 1, 0.88, 1)
                    }),
                    {
                        target: track,
                        offset: ['start start', 'end end']
                    }
                );

                // Scale Animation
                scroll(
                    animate(layer, { scale: [0, 0, 1] }, {
                        offset: [0, 0.3, 1],
                        easing: scaleEasings[index] || scaleEasings[0]
                    }),
                    {
                        target: track,
                        offset: ['start start', 'end end']
                    }
                );
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            gsap.registerPlugin(ScrollTrigger);

            const lenis = new Lenis();
            lenis.on("scroll", ScrollTrigger.update);
            gsap.ticker.add((time) => {
                lenis.raf(time * 1000);
            });
            gsap.ticker.lagSmoothing(0);

            // Updated Selector
            const textBlocks = document.querySelectorAll(".kinetic-typography-block p");

            // Updated RGB value for the lighter background highlight (a slate blue tone)
            const wordHighlightRGB = "45, 59, 85";

            const specialKeywords = [
                "designed",
                "natural",
                "control",
                "ideas",
                "smooth",
                "performance",
                "creation",
                "attention",
                "value",
            ];

            textBlocks.forEach((paragraph) => {
                const textContent = paragraph.textContent;
                const splitWords = textContent.split(/\s+/);
                paragraph.innerHTML = "";

                splitWords.forEach((wordStr) => {
                    if (wordStr.trim()) {
                        const tokenContainer = document.createElement("div");
                        // Updated Class Name
                        tokenContainer.className = "token-unit";

                        const innerSpan = document.createElement("span");
                        innerSpan.textContent = wordStr;

                        const cleanWord = wordStr.toLowerCase().replace(/[.,!?;:"]/g, "");

                        if (specialKeywords.includes(cleanWord)) {
                            // Updated Class Names
                            tokenContainer.classList.add("highlight-anchor");
                            innerSpan.classList.add("emphasis-pill", cleanWord);
                        }

                        tokenContainer.appendChild(innerSpan);
                        paragraph.appendChild(tokenContainer);
                    }
                });
            });

            // Updated Selector
            const scrollHosts = document.querySelectorAll(".scroll-sequence-host");

            scrollHosts.forEach((hostEl) => {
                ScrollTrigger.create({
                    trigger: hostEl,
                    pin: hostEl,
                    start: "top top",
                    end: `+=${window.innerHeight * 4}`,
                    pinSpacing: true,
                    onUpdate: (self) => {
                        const progress = self.progress;
                        // Updated Selector
                        const allTokens = Array.from(
                            hostEl.querySelectorAll(".kinetic-typography-block .token-unit")
                        );
                        const totalTokens = allTokens.length;

                        allTokens.forEach((token, idx) => {
                            const innerText = token.querySelector("span");

                            if (progress <= 0.7) {
                                // Reveal Phase
                                const progressTarget = 0.7;
                                const revealProgress = Math.min(1, progress / progressTarget);

                                const overlapCount = 15;
                                const animLength = 1 + overlapCount / totalTokens;

                                const startP = idx / totalTokens;
                                const endP = startP + overlapCount / totalTokens;

                                const timeScale = 1 / Math.min(
                                    animLength,
                                    1 + (totalTokens - 1) / totalTokens + overlapCount / totalTokens
                                );

                                const adjStart = startP * timeScale;
                                const adjEnd = endP * timeScale;
                                const duration = adjEnd - adjStart;

                                const tokenProgress = revealProgress <= adjStart
                                    ? 0
                                    : revealProgress >= adjEnd
                                        ? 1
                                        : (revealProgress - adjStart) / duration;

                                token.style.opacity = tokenProgress;

                                // Background Highlight Logic
                                const bgFadeStart = tokenProgress >= 0.9 ? (tokenProgress - 0.9) / 0.1 : 0;
                                const bgOpacity = Math.max(0, 1 - bgFadeStart);
                                token.style.backgroundColor = `rgba(${wordHighlightRGB}, ${bgOpacity})`;

                                // Text Opacity Logic
                                const textThreshold = 0.9;
                                const textRevealP = tokenProgress >= textThreshold
                                    ? (tokenProgress - textThreshold) / (1 - textThreshold)
                                    : 0;

                                innerText.style.opacity = Math.pow(textRevealP, 0.5);

                            } else {
                                // Exit Phase (Reverse/Fade)
                                const reverseProgress = (progress - 0.7) / 0.3;
                                token.style.opacity = 1;
                                const targetOpacity = 1;

                                const revOverlap = 5;
                                const revStart = idx / totalTokens;
                                const revEnd = revStart + revOverlap / totalTokens;

                                const revScale = 1 / Math.max(
                                    1,
                                    (totalTokens - 1) / totalTokens + revOverlap / totalTokens
                                );

                                const revAdjStart = revStart * revScale;
                                const revAdjEnd = revEnd * revScale;
                                const revDur = revAdjEnd - revAdjStart;

                                const revTokenP = reverseProgress <= revAdjStart
                                    ? 0
                                    : reverseProgress >= revAdjEnd
                                        ? 1
                                        : (reverseProgress - revAdjStart) / revDur;

                                if (revTokenP > 0) {
                                    innerText.style.opacity = targetOpacity * (1 - revTokenP);
                                    token.style.backgroundColor = `rgba(${wordHighlightRGB}, ${revTokenP})`;
                                } else {
                                    innerText.style.opacity = targetOpacity;
                                    token.style.backgroundColor = `rgba(${wordHighlightRGB}, 0)`;
                                }
                            }
                        });
                    },
                });
            });
        });
    </script>
    <script>
        gsap.registerPlugin(ScrollTrigger);

        // --- 0. LOADER ANIMATION (OSMO/WILLEM) ---
        function initLoader() {
            const container = document.querySelector('.loader-screen');
            const loadingLetter = container.querySelectorAll('.willem__letter');
            const box = container.querySelectorAll('.willem-loader__box');
            const growingImage = container.querySelectorAll('.willem__growing-image');
            const headingStart = container.querySelectorAll('.willem__h1-start');
            const headingEnd = container.querySelectorAll('.willem__h1-end');
            const coverImageExtra = container.querySelectorAll('.willem__cover-image-extra');

            const tl = gsap.timeline({
                defaults: { ease: 'expo.inOut' },
                onComplete: () => {
                    document.body.classList.remove('is-loading');
                    gsap.to(container, {
                        opacity: 0,
                        display: 'none',
                        duration: 0.5,
                        onComplete: () => ScrollTrigger.refresh()
                    });
                }
            });

            if (loadingLetter) { tl.from(loadingLetter, { yPercent: 100, stagger: 0.025, duration: 1.25 }); }
            if (box.length) { tl.fromTo(box, { width: '0em' }, { width: '1em', duration: 1.25 }, '< 1.25'); }
            if (growingImage.length) { tl.fromTo(growingImage, { width: '0%' }, { width: '100%', duration: 1.25 }, '<'); }
            if (headingStart.length) { tl.fromTo(headingStart, { x: '0em' }, { x: '-0.05em', duration: 1.25 }, '<'); }
            if (headingEnd.length) { tl.fromTo(headingEnd, { x: '0em' }, { x: '0.05em', duration: 1.25 }, '<'); }
            if (coverImageExtra.length) { tl.fromTo(coverImageExtra, { opacity: 1 }, { opacity: 0, duration: 0.05, ease: 'none', stagger: 0.5 }, '-=0.05'); }
            if (growingImage.length) { tl.to(growingImage, { width: '100vw', height: '100vh', duration: 1.5 }, '< 1.25'); }
            if (box.length) { tl.to(box, { width: '100vw', duration: 1.5 }, '<'); }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initLoader();
            initCarousel();
            initGlobalPageCursor();
            initFooterCursor();
            initFooterAnimations();
            init3DMarker();
        });

        // --- GLOBAL PAGE CURSOR ANIMATION (NEW FUNCTION) ---
        function initGlobalPageCursor() {
            const globalCanvas = document.querySelector('#global-cursor-canvas');
            if (!globalCanvas) return;

            const globalCtx = globalCanvas.getContext('2d');
            let globalMouseMoved = false;

            const globalPointer = {
                x: 0.5 * window.innerWidth,
                y: 0.5 * window.innerHeight,
            };

            const params = {
                pointsNumber: 40,
                widthFactor: 0.3,
                mouseThreshold: 0.6,
                spring: 0.4,
                friction: 0.5,
            };

            const trail = new Array(params.pointsNumber);
            for (let i = 0; i < params.pointsNumber; i++) {
                trail[i] = {
                    x: globalPointer.x,
                    y: globalPointer.y,
                    dx: 0,
                    dy: 0,
                };
            }

            window.addEventListener('click', e => {
                updateGlobalMousePosition(e.clientX, e.clientY);
            });
            window.addEventListener('mousemove', e => {
                globalMouseMoved = true;
                updateGlobalMousePosition(e.clientX, e.clientY);
            });
            window.addEventListener('touchmove', e => {
                globalMouseMoved = true;
                updateGlobalMousePosition(e.targetTouches[0].clientX, e.targetTouches[0].clientY);
            });

            function updateGlobalMousePosition(eX, eY) {
                globalPointer.x = eX;
                globalPointer.y = eY;
            }

            function setupGlobalCanvas() {
                globalCanvas.width = window.innerWidth;
                globalCanvas.height = window.innerHeight;
            }

            function updateGlobal(t) {
                // Idle motion when mouse isn't moving
                if (!globalMouseMoved) {
                    globalPointer.x = (0.5 + 0.3 * Math.cos(0.002 * t) * Math.sin(0.005 * t)) * window.innerWidth;
                    globalPointer.y = (0.5 + 0.2 * Math.cos(0.005 * t) + 0.1 * Math.cos(0.01 * t)) * window.innerHeight;
                }

                globalCtx.clearRect(0, 0, globalCanvas.width, globalCanvas.height);

                trail.forEach((p, pIdx) => {
                    const prev = pIdx === 0 ? globalPointer : trail[pIdx - 1];
                    const spring = pIdx === 0 ? 0.4 * params.spring : params.spring;
                    p.dx += (prev.x - p.x) * spring;
                    p.dy += (prev.y - p.y) * spring;
                    p.dx *= params.friction;
                    p.dy *= params.friction;
                    p.x += p.dx;
                    p.y += p.dy;
                });

                globalCtx.lineCap = 'round';
                // Set color to white because we used mix-blend-mode: difference in CSS
                // This makes it look inverted on all backgrounds
                globalCtx.strokeStyle = '#ffffff';

                globalCtx.beginPath();
                globalCtx.moveTo(trail[0].x, trail[0].y);

                for (let i = 1; i < trail.length - 1; i++) {
                    const xc = 0.5 * (trail[i].x + trail[i + 1].x);
                    const yc = 0.5 * (trail[i].y + trail[i + 1].y);
                    globalCtx.quadraticCurveTo(trail[i].x, trail[i].y, xc, yc);
                    globalCtx.lineWidth = params.widthFactor * (params.pointsNumber - i);
                    globalCtx.stroke();
                }
                globalCtx.lineTo(trail[trail.length - 1].x, trail[trail.length - 1].y);
                globalCtx.stroke();

                window.requestAnimationFrame(updateGlobal);
            }

            window.addEventListener('resize', setupGlobalCanvas);

            // Initialize
            setupGlobalCanvas();
            updateGlobal(0);
        }

        // --- 1. URBANIST LOGIC ---
        const integrationSection = document.getElementById("urbanist-integration");
        const panes = gsap.utils.toArray(".pane");
        gsap.set(panes, { width: window.innerWidth });

        const themes = [
            { mainBg: "#b9dcff", subBg: "#f2fbfe", text: "#070f36", title: "#8dc9f4" },
            { mainBg: "#fff58c", subBg: "#fbf1ed", text: "#9c4e23", title: "#9c4e23" },
            { mainBg: "#c4ffb2", subBg: "#f1ffec", text: "#164c3b", title: "#164c3b" }
        ];

        const thresholds = new Array(panes.length).fill(0).map((_, i) => parseFloat(((1 / panes.length) * i).toFixed(2)));
        let activeThemeIndex = 0;

        gsap.to(panes, {
            xPercent: -100 * (panes.length - 1),
            ease: "none",
            scrollTrigger: {
                trigger: integrationSection,
                pin: true,
                scrub: 1,
                start: "top top",
                end: () => "+=" + (window.innerWidth * panes.length * 0.5),
                onUpdate: (self) => {
                    const progress = parseFloat(self.progress.toFixed(2));
                    const themeIndex = thresholds.findLastIndex((threshold) => progress >= threshold);
                    if (themeIndex !== activeThemeIndex && themeIndex >= 0) {
                        activeThemeIndex = themeIndex;
                        updateTheme(themeIndex);
                    }
                }
            }
        });

        function updateTheme(themeIndex) {
            const theme = themes[themeIndex];
            gsap.to(document.documentElement, {
                "--theme-main-bg": theme.mainBg,
                "--theme-sub-bg": theme.subBg,
                "--theme-title": theme.title,
                "--theme-text": theme.text,
                duration: 1,
                ease: "power2.out"
            });
        }

        // --- 2. PERSPECTIVE ZOOM LOGIC ---
        const zoomTimeline = gsap.timeline({
            scrollTrigger: {
                trigger: ".zoom-container",
                start: "top top",
                end: "+=200%",
                scrub: 1,
                pin: true
            }
        });
        zoomTimeline.to(".zoom-item[data-layer='3']", { z: 1000, opacity: 0, ease: "power1.in" }, 0);
        zoomTimeline.to(".zoom-item[data-layer='2']", { z: 600, opacity: 0, ease: "power1.in" }, 0.1);
        zoomTimeline.to(".zoom-item[data-layer='1']", { z: 300, opacity: 0, ease: "power1.in" }, 0.2);
        zoomTimeline.to(".heading-zoom", { z: 200, opacity: 1, scale: 1.5, ease: "power1.out" }, 0);

        // --- 3. TEXT REVEAL LOGIC ---
        const textElement = document.querySelector(".opacity-reveal");
        const textContent = textElement.innerText;
        textElement.innerHTML = '';
        textContent.split('').forEach(char => {
            const span = document.createElement('span');
            span.innerText = char;
            span.style.opacity = "0.1";
            textElement.appendChild(span);
        });
        const chars = textElement.querySelectorAll('span');
        const textTimeline = gsap.timeline({
            scrollTrigger: {
                trigger: ".section-stick",
                start: "center center",
                end: "+=150%",
                pin: true,
                scrub: 0.5
            }
        });
        textTimeline.to(chars, { opacity: 1, stagger: 0.02, duration: 1, ease: "none" })
            .to(textElement, { scale: 1.1, duration: 1, ease: "power2.out" }, "<");

        // --- 4. ALICE SECTION LOGIC ---
        const heroReveal = document.querySelectorAll(".hero-reveal");
        heroReveal.forEach((element) => {
            const heroBox = element.querySelector(".hero-reveal__header");
            const heroHeadings = element.querySelectorAll(".hero-reveal_split_item");
            const contentEl = element.querySelector(".hero-reveal__content");
            if (!heroBox || !contentEl) return;
            const heroBoxHeight = heroBox.offsetHeight;
            const contentHeight = contentEl.offsetHeight;
            const pinDistance = heroBoxHeight > contentHeight ? heroBoxHeight : contentHeight;

            gsap.fromTo(contentEl, { y: "50%" }, {
                y: "0%", ease: "none",
                scrollTrigger: { trigger: element, start: "top top", end: `+=${pinDistance}`, scrub: true }
            });

            const tl = gsap.timeline({ scrollTrigger: { trigger: element, start: "top top", end: `+=${pinDistance}`, scrub: true, pin: true } });
            tl.fromTo(heroBox, { clipPath: "inset(0% 0% 0% 0%)" }, { clipPath: "inset(0% 0% 100% 0%)", duration: 1, ease: "power1.inOut" });

            if (heroHeadings.length >= 2) {
                tl.fromTo(heroHeadings[0], { y: "0%" }, { y: "-30%", ease: "power1.inOut" }, 0);
                tl.fromTo(heroHeadings[1], { y: "0%" }, { y: "30%", ease: "power1.inOut" }, 0);
            }
        });

        function parallaxScrollBySpeed(selector, speed = 1, trigger = ".hero-reveal") {
            const el = document.querySelector(selector);
            const contentEl = document.querySelector(".hero-reveal__content");
            if (!el || !contentEl) return;
            const contentHeight = contentEl.offsetHeight;
            gsap.to(el, {
                yPercent: (speed - 1) * 100, ease: "none",
                scrollTrigger: { trigger: trigger, start: "top top", end: `+=${contentHeight * 2}`, scrub: true }
            });
        }
        parallaxScrollBySpeed(".hero-reveal__parallax-book", 15);
        parallaxScrollBySpeed(".hero-reveal__parallax-clock", 13);
        parallaxScrollBySpeed(".hero-reveal__parallax-alice", 6);
        parallaxScrollBySpeed(".hero-reveal__parallax-kattle", 23);
        parallaxScrollBySpeed(".hero-reveal__parallax-card", 5);

        // --- 5. CAROUSEL SECTION LOGIC (FIXED & STABLE) ---
        function initCarousel() {
            // We pin the section for 4000px.
            // We use a timeline that is scrubbed by the scroll.
            // This allows smooth forward/backward scrubbing with no logic errors.

            const carouselSection = document.querySelector("#carousel-section");
            const slides = gsap.utils.toArray(".slide"); // Get all pre-rendered slides

            // Create a timeline that spans the pinning duration
            const tl = gsap.timeline({
                scrollTrigger: {
                    trigger: carouselSection,
                    start: "top top",
                    end: "+=4000",
                    scrub: 1, // Smooth scrubbing, user can reverse easily
                    pin: true
                }
            });
            // 1. Reveal Slide 2
            tl.to("#slide-2", {
                clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                duration: 1,
                ease: "none" // Linear ease for direct mapping to scroll
            });

            // 2. Reveal Slide 3
            tl.to("#slide-3", {
                clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                duration: 1,
                ease: "none"
            });

            // 3. Reveal Slide 4
            tl.to("#slide-4", {
                clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                duration: 1,
                ease: "none"
            });

            // Add a small buffer at the end so the user sees the last slide before unpinning
            tl.to({}, { duration: 0.5 });
        }

        // --- 6. FOOTER CURSOR LOGIC ---
        function initFooterCursor() {
            const canvas = document.querySelector('#footer-canvas');
            const footer = document.querySelector('#advanced-footer');
            if (!canvas || !footer) return;

            const ctx = canvas.getContext('2d');
            let mouseMoved = false;

            const pointer = { x: 0.5 * window.innerWidth, y: 0.5 * window.innerHeight };
            const params = {
                pointsNumber: 40,
                widthFactor: 0.3,
                mouseThreshold: 0.6,
                spring: 0.4,
                friction: 0.5,
            };

            const trail = new Array(params.pointsNumber);
            for (let i = 0; i < params.pointsNumber; i++) {
                trail[i] = { x: pointer.x, y: pointer.y, dx: 0, dy: 0 };
            }

            // Listen to movements on the FOOTER specifically to handle offsets correctly
            footer.addEventListener('mousemove', e => {
                mouseMoved = true;
                const rect = footer.getBoundingClientRect();
                // Calculate position relative to the footer canvas
                pointer.x = e.clientX - rect.left;
                pointer.y = e.clientY - rect.top;
            });

            // Also handle global window resizing
            window.addEventListener('resize', setupCanvas);

            function setupCanvas() {
                const rect = footer.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
            }

            function update(t) {
                // If mouse hasn't moved yet, create a gentle idle animation
                if (!mouseMoved) {
                    pointer.x = (0.5 + 0.3 * Math.cos(0.002 * t) * Math.sin(0.005 * t)) * canvas.width;
                    pointer.y = (0.5 + 0.2 * Math.cos(0.005 * t) + 0.1 * Math.cos(0.01 * t)) * canvas.height;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                trail.forEach((p, pIdx) => {
                    const prev = pIdx === 0 ? pointer : trail[pIdx - 1];
                    const spring = pIdx === 0 ? 0.4 * params.spring : params.spring;
                    p.dx += (prev.x - p.x) * spring;
                    p.dy += (prev.y - p.y) * spring;
                    p.dx *= params.friction;
                    p.dy *= params.friction;
                    p.x += p.dx;
                    p.y += p.dy;
                });

                ctx.lineCap = 'round';
                ctx.strokeStyle = '#ffffff'; // White trail on black footer
                ctx.beginPath();
                ctx.moveTo(trail[0].x, trail[0].y);

                for (let i = 1; i < trail.length - 1; i++) {
                    const xc = 0.5 * (trail[i].x + trail[i + 1].x);
                    const yc = 0.5 * (trail[i].y + trail[i + 1].y);
                    ctx.quadraticCurveTo(trail[i].x, trail[i].y, xc, yc);
                    ctx.lineWidth = params.widthFactor * (params.pointsNumber - i);
                    ctx.stroke();
                }
                ctx.lineTo(trail[trail.length - 1].x, trail[trail.length - 1].y);
                ctx.stroke();

                window.requestAnimationFrame(update);
            }

            setupCanvas();
            update(0);
        }

        // --- 7. FOOTER REVEAL ANIMATIONS ---
        function initFooterAnimations() {
            const footer = document.querySelector('#advanced-footer');
            const bigText = footer.querySelector('.footer-big-text');
            const links = footer.querySelectorAll('.footer-links a');
            const bottom = footer.querySelector('.footer-bottom');

            // Animate Big Text
            gsap.to(bigText, {
                opacity: 1,
                y: 0,
                duration: 1.5,
                ease: "power3.out",
                scrollTrigger: {
                    trigger: footer,
                    start: "top 75%",
                }
            });

            // Animate Links Stagger
            gsap.to(links, {
                y: 0,
                duration: 1,
                stagger: 0.1,
                ease: "power3.out",
                scrollTrigger: {
                    trigger: footer,
                    start: "top 75%",
                }
            });

            // Animate Bottom Bar
            gsap.to(bottom, {
                opacity: 1,
                duration: 1,
                delay: 0.5,
                scrollTrigger: {
                    trigger: footer,
                    start: "top 80%",
                }
            });
        }
    </script>
    <script type="module">
        import LiquidBackground from 'https://cdn.jsdelivr.net/npm/threejs-components@0.0.27/build/backgrounds/liquid1.min.js'

        const canvasElement = document.getElementById('liquid-canvas');
        if (canvasElement) {
            const app = LiquidBackground(canvasElement)

            // Load the image and set parameters
            app.loadImage('https://assets.codepen.io/33787/liquid.webp')
            app.liquidPlane.material.metalness = 0.75
            app.liquidPlane.material.roughness = 0.25
            app.liquidPlane.uniforms.displacementScale.value = 5
            app.setRain(false)
        }
    </script>
    <script>
     // Target the NEW container ID
const modelViewer = document.querySelector('#threejs-marker-container');

if (modelViewer) {
    gsap.to(modelViewer, {
        opacity: 0,
        ease: "none",
        scrollTrigger: {
            trigger: "#urbanist-integration", 
            start: "top bottom", 
            end: "top center",   
            scrub: true,
            // Optimization: hide it completely when invisible so it doesn't render
            onLeave: () => { modelViewer.style.display = 'none'; },
            onEnterBack: () => { modelViewer.style.display = 'block'; }
        }
    });
}
    </script>
<script>function init3DMarker() {
    const container = document.getElementById('threejs-marker-container');
    if (!container) return;

    // 1. SCENE & CAMERA
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 28;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // 2. LIGHTING
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(10, 10, 20);
    dirLight.castShadow = true;
    scene.add(dirLight);

    const spotLight = new THREE.SpotLight(0xffffff, 0.8);
    spotLight.position.set(-10, 0, 10);
    scene.add(spotLight);

    // 3. MATERIALS & TEXTURE
    function createLabelTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 1024; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#fcfcfc'; 
        ctx.fillRect(0, 0, 1024, 512);
        
        ctx.fillStyle = '#000000'; 
        ctx.font = '900 130px Helvetica, Arial'; 
        ctx.textAlign = 'center';
        ctx.fillText('WHITE BOARD', 512, 250);

        ctx.fillStyle = '#d91c24'; 
        ctx.fillRect(720, 170, 250, 90);
        ctx.fillStyle = '#ffffff'; 
        ctx.font = 'bold 60px Helvetica, Arial'; 
        ctx.fillText('Camlin', 845, 235);
        
        return new THREE.CanvasTexture(canvas);
    }

    const labelTex = createLabelTexture();
    labelTex.wrapS = THREE.RepeatWrapping;
    labelTex.repeat.set(-1, 1);
    labelTex.offset.set(0.75, 0);

    const matBody = new THREE.MeshStandardMaterial({ map: labelTex, roughness: 0.3, metalness: 0.05 });
    const matRed = new THREE.MeshStandardMaterial({ color: 0xd91c24, roughness: 0.2, metalness: 0.1 });
    const matNib = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
    const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });

    // 4. MESHES
    const markerSystem = new THREE.Group();
    scene.add(markerSystem);

    // --- BODY GROUP ---
    const bodyGroup = new THREE.Group();
    markerSystem.add(bodyGroup);
    
    const r = 0.8; 
    const len = 8.0; 

    const cyl = new THREE.Mesh(new THREE.CylinderGeometry(r, r, len, 64), matBody);
    cyl.rotation.y = Math.PI; 
    cyl.castShadow = true;
    bodyGroup.add(cyl);

    const plug = new THREE.Mesh(new THREE.CylinderGeometry(r, r, 0.5, 64), matRed);
    plug.position.y = (len/2) + 0.25;
    bodyGroup.add(plug);

    const taper = new THREE.Mesh(new THREE.CylinderGeometry(r, 0.45, 1.8, 64), matWhite);
    taper.position.y = -(len/2) - 0.9;
    bodyGroup.add(taper);

    const nib = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.9, 32), matNib);
    nib.position.y = -(len/2) - 2.1;
    nib.rotation.z = Math.PI; 
    bodyGroup.add(nib);

    // --- CAP GROUP ---
    const capGroup = new THREE.Group();
    markerSystem.add(capGroup);
    const capLen = 3.8; const capR = r + 0.12;

    const capShell = new THREE.Mesh(new THREE.CylinderGeometry(capR-0.05, capR, capLen, 64), matRed);
    capShell.geometry.translate(0, capLen/2, 0); 
    capShell.castShadow = true;
    capGroup.add(capShell);

    const ring = new THREE.Mesh(new THREE.CylinderGeometry(capR+0.1, capR+0.1, 0.6, 64), matRed);
    ring.position.y = 0.5;
    capGroup.add(ring);

    const clip = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2.8, 0.5), matRed);
    clip.position.set(capR + 0.05, 2.0, 0);
    capGroup.add(clip);

    // 5. INITIAL POSITIONING (Will be overridden by responsive logic below)
    markerSystem.rotation.z = -Math.PI / 4; 

    // 6. ANIMATION
    const closedY = -5.0; 
    const openY = -14.0; 
    capGroup.position.y = openY;

    const tl = gsap.timeline({
        scrollTrigger: {
            trigger: ".hero",
            start: "top top",
            end: "80% top",
            scrub: 1.2,
        }
    });

    tl.to(capGroup.position, {
        y: closedY,
        ease: "power2.out"
    });

    // 7. RENDER LOOP
    function animate() {
        requestAnimationFrame(animate);
        markerSystem.position.y += Math.sin(Date.now() * 0.001) * 0.002;
        renderer.render(scene, camera);
    }
    animate();


    // --- 8. RESPONSIVE LOGIC (NEW) ---
    function updateLayout() {
        // Update camera and renderer first
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);

        // CHECK SCREEN WIDTH
        if (width < 768) {
            // === MOBILE SETTINGS ===
            // 1. Scale it down to 55%
            markerSystem.scale.set(0.55, 0.55, 0.55);
            // 2. Move it closer to center (X=2) because screen is narrow
            markerSystem.position.set(2.0, 1.5, 0); 
        } else {
            // === DESKTOP SETTINGS ===
            // 1. Full Size
            markerSystem.scale.set(1, 1, 1);
            // 2. Original Position (Right side)
            markerSystem.position.set(6.5, 2, 0);
        }
    }

    // Run once on load
    updateLayout();

    // Run whenever window resizes
    window.addEventListener('resize', updateLayout);
}</script>
</body>

</html>