<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARKER - Studio</title>
    <!-- Fonts -->
    <link rel="preload" href="./assets/fonts/Presicav.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="./assets/fonts/Calibre-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="./assets/fonts/Arial.woff2" as="font" type="font/woff2" crossorigin="anonymous">

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://api.fontshare.com/v2/css?f[]=neue-montreal@500&display=swap" rel="stylesheet">

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <link rel="stylesheet" crossorigin href="./css/index.min.css?v=1754734869502">
    <link rel="stylesheet" href="./style.css">
    <style>
        /* Specific overrides for standalone playground */
        body {
            overflow: hidden;
            /* Lock scroll strictly for app feel */
            background-color: #f4f4f4;
            overscroll-behavior: none;
            /* Prevent bounce on Mac */
        }

        .playground-wrapper {
            height: 100vh;
            width: 100vw;
            position: relative;
            cursor: crosshair;
            /* Default cursor */
        }

        .playground-wrapper.panning {
            cursor: grab;
        }

        .playground-wrapper.panning:active {
            cursor: grabbing;
        }

        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            padding: 10px 20px;
            background: black;
            color: white;
            text-decoration: none;
            font-family: 'Neue Montreal', sans-serif;
            border-radius: 20px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        .back-btn:hover {
            background: #333;
        }

        /* Extra UI for Zoom/Pan */
        .zoom-controls {
            position: absolute;
            bottom: 30px;
            left: 30px;
            display: flex;
            gap: 10px;
            z-index: 1000;
            /* Increased z-index */
            pointer-events: auto;
            /* Explicitly allowed */
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 1px solid #ddd;
            background: white;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .zoom-btn:hover {
            background: #eee;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .zoom-controls {
                bottom: 120px;
                /* Moved UP significantly */
                left: 20px;
            }

            .playground-ui {
                bottom: 20px;
                /* Adjust main UI bar if needed */
                max-width: 95%;
                /* Prevent edge clipping */
                flex-wrap: wrap;
                /* Allow wrapping if too many tools */
                gap: 5px;
            }

            .tool-btn,
            .zoom-btn,
            .back-btn {
                min-width: 44px;
                /* Touch target size standards */
                min-height: 44px;
            }

            .back-btn {
                top: 15px;
                left: 15px;
                padding: 12px 20px;
                /* Larger hit area */
            }

            /* Stack tools for better mobile layout if needed */
            .tools-group {
                gap: 5px;
            }
        }
    </style>
</head>

<body>
    <!-- Transition Overlay for Entrance/Exit -->
    <div class="transition-overlay"
        style="position:fixed; top:0; left:0; width:100vw; height:100vh; background:#000; z-index:9999; transform-origin:bottom;">
    </div>

    <a href="#" class="back-btn" onclick="goHome(event)">‚Üê Back to Home</a>

    <section id="drawing-playground" class="viewport-section" style="height: 100vh; padding: 0;">
        <div class="playground-wrapper" id="playground-wrapper">

            <div class="grid-layer" id="grid-layer" style="transform-origin: 0 0;"></div>

            <div class="playground-ui">
                <div class="ui-header">
                    <h3>Studio</h3>
                </div>

                <div class="color-picker">
                    <button class="color-btn active" data-color="#000000" style="background-color: #000000;"
                        title="Black"></button>
                    <button class="color-btn" data-color="#d91c24" style="background-color: #d91c24;"
                        title="Red"></button>
                    <button class="color-btn" data-color="#2b4eff" style="background-color: #2b4eff;"
                        title="Blue"></button>
                    <button class="color-btn" data-color="#00a651" style="background-color: #00a651;"
                        title="Green"></button>
                </div>

                <div class="tools-group">
                    <button id="btn-pan" class="tool-btn" title="Pan Tool (Space)">
                        <!-- Hand/Pan Icon -->
                        <svg class="tool-icon" viewBox="0 0 24 24" width="24" height="24">
                            <path fill="currentColor"
                                d="M23,5.5V20c0,2.2-1.8,4-4,4h-7.3c-1.08,0-2.1-0.43-2.85-1.19L1,14.83l3.77-3.79 c0.45-0.45,1.2-0.58,1.76-0.3l0.47,0.26V2.5C7,1.4,7.9,0.5,9,0.5S11,1.4,11,2.5V7h1V1.5C12,0.4,12.9-0.5,14-0.5S16,0.4,16,1.5V7h1 V2.5c0-1.1,0.9-2,2-2s2,0.9,2,2V7h1V5.5C22,4.4,22.9,3.5,24,3.5S26,4.4,26,5.5z M10,12V2.5l0,0c0-0.55-0.45-1-1-1s-1,0.45-1,1V12 H10z M14,12V1.5l0,0c0-0.55-0.45-1-1-1s-1,0.45-1,1V12H14z M18,12V2.5l0,0c0-0.55-0.45-1-1-1s-1,0.45-1,1V12H18z M22,12V5.5l0,0 c0-0.55-0.45-1-1-1s-1,0.45-1,1V12H22z"
                                transform="scale(0.8) translate(2,4)" />
                        </svg>
                        <span>Pan</span>
                    </button>

                    <button id="btn-marker" class="tool-btn active" title="Marker (M)">
                        <svg class="tool-icon" viewBox="0 0 24 24" width="24" height="24">
                            <path fill="currentColor"
                                d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" />
                        </svg>
                        <span>Marker</span>
                    </button>

                    <button id="btn-eraser" class="tool-btn" title="Eraser (E)">
                        <svg class="tool-icon" viewBox="0 0 24 24" width="24" height="24">
                            <path fill="currentColor"
                                d="M16.24 3.56l4.95 4.94c.78.79.78 2.05 0 2.84L12 20.53a4.008 4.008 0 0 1-5.66 0L2.81 17c-.78-.79-.78-2.05 0-2.84l10.6-10.6c.79-.78 2.05-.78 2.83 0zM4.22 15.58l3.54 3.53c.78.79 2.04.79 2.83 0l8.48-8.48-3.54-3.54-11.31 11.31v-.01z" />
                        </svg>
                        <span>Eraser</span>
                    </button>

                    <button id="btn-grid" class="tool-btn" title="Toggle Grid (G)">
                        <svg class="tool-icon" viewBox="0 0 24 24" width="24" height="24">
                            <path fill="currentColor"
                                d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 20H4v-4h4v4zm0-6H4v-4h4v4zm0-6H4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4z" />
                        </svg>
                        <span>Grid Off</span>
                    </button>

                    <button id="btn-save" class="tool-btn" title="Save Image (S)">
                        <svg class="tool-icon" viewBox="0 0 24 24" width="24" height="24">
                            <path fill="currentColor" d="M5 20h14v-2H5v2zM19 9h-4V3H9v6H5l7 7 7-7z" />
                        </svg>
                        <span>Save</span>
                    </button>
                </div>

                <button id="btn-clear" class="action-btn">Clear</button>
            </div>

            <div class="zoom-controls">
                <button class="zoom-btn" id="btn-zoom-out" title="Zoom Out (-)">-</button>
                <button class="zoom-btn" id="btn-zoom-reset" title="Reset View (0)"
                    style="font-size: 0.8rem; width: auto; padding: 0 15px; border-radius: 20px;">100%</button>
                <button class="zoom-btn" id="btn-zoom-in" title="Zoom In (+)">+</button>
            </div>

            <canvas id="playground-canvas"></canvas>
        </div>
    </section>

    <script>
        function initPlayground() {
            const canvas = document.getElementById('playground-canvas');
            const container = document.getElementById('playground-wrapper');
            const gridLayer = document.getElementById('grid-layer');
            const zoomLabel = document.getElementById('btn-zoom-reset');

            if (!canvas || !container) return;

            const ctx = canvas.getContext('2d');

            // --- STATE ---
            let strokes = []; // { points: [{x,y}, ...], color, size, isEraser }
            let currentStroke = null;

            let camera = { x: 0, y: 0, zoom: 1 };
            let isDragging = false;
            let lastMouse = { x: 0, y: 0 };

            // Tools: 'marker', 'eraser', 'pan'
            let activeTool = 'marker';
            let currentColor = '#000000';
            let currentSize = 6;
            let isEraser = false; // Flag for drawing logic

            // --- 1. SETUP CANVAS & RESIZE ---
            function resize() {
                const dpr = window.devicePixelRatio || 1;
                const rect = container.getBoundingClientRect();

                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;

                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';

                // Reset context scale/transform because canvas resize clears it
                // We handle transform in the render loop manually
                render();
            }
            window.addEventListener('resize', resize);
            resize(); // Initial call

            // --- 2. COORDINATE SYSTEMS ---
            // Screen (Pixel) -> World (Infinite Canvas)
            function toWorld(screenX, screenY) {
                const dpr = window.devicePixelRatio || 1;
                // Canvas coordinates are scaled by DPR, so we adjust screen input first
                return {
                    x: (screenX * dpr - camera.x) / camera.zoom,
                    y: (screenY * dpr - camera.y) / camera.zoom
                };
            }

            // World -> Screen
            function toScreen(worldX, worldY) {
                // Not strictly needed for drawing, but useful for debugging
                return {
                    x: worldX * camera.zoom + camera.x,
                    y: worldY * camera.zoom + camera.y
                };
            }

            // --- 3. RENDER LOOP ---
            function render() {
                const dpr = window.devicePixelRatio || 1;

                // Clear the entire physical canvas
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.restore();

                // Apply Camera Transform
                ctx.save();
                ctx.translate(camera.x, camera.y);
                ctx.scale(camera.zoom, camera.zoom);

                // Draw All Strokes
                strokes.forEach(stroke => drawStroke(stroke));
                // Draw Current Stroke (if valid)
                if (currentStroke) drawStroke(currentStroke);

                ctx.restore();

                // Update Grid appearance (optional visual feedback)
                if (gridLayer) {
                    gridLayer.style.backgroundSize = `${40 * camera.zoom}px ${40 * camera.zoom}px`;
                    gridLayer.style.backgroundPosition = `${camera.x / dpr}px ${camera.y / dpr}px`;
                }

                // Update Label
                if (zoomLabel) zoomLabel.innerText = Math.round(camera.zoom * 100) + "%";
            }

            function drawStroke(stroke) {
                if (stroke.points.length < 1) return;

                ctx.lineWidth = stroke.size;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                if (stroke.isEraser) {
                    // For eraser to work on a transparent canvas, we use destination-out
                    // BUT: inside the transform stack, this works relative to existing pixels.
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineWidth = stroke.size * 8; // Eraser is MUCH bigger (increased from 2)
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = stroke.color;
                }

                ctx.beginPath();
                const p0 = stroke.points[0];
                ctx.moveTo(p0.x, p0.y);

                if (stroke.points.length < 3) {
                    // Dot
                    ctx.lineTo(p0.x, p0.y);
                    ctx.stroke();
                    return;
                }

                for (let i = 1; i < stroke.points.length - 2; i++) {
                    const c = (stroke.points[i].x + stroke.points[i + 1].x) / 2;
                    const d = (stroke.points[i].y + stroke.points[i + 1].y) / 2;
                    ctx.quadraticCurveTo(stroke.points[i].x, stroke.points[i].y, c, d);
                }

                const i = stroke.points.length - 2;
                ctx.quadraticCurveTo(stroke.points[i].x, stroke.points[i].y, stroke.points[i + 1].x, stroke.points[i + 1].y);
                ctx.stroke();
            }

            // --- 4. INPUT HANDLING ---
            function getPointerPos(e) {
                const rect = container.getBoundingClientRect();
                // For single touch/mouse
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: clientX - rect.left, y: clientY - rect.top };
            }

            // Pinch Helpers
            let initialPinchDist = null;
            let lastPinchZoom = 1;

            function getPinchDist(e) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                return Math.hypot(dx, dy);
            }

            function getPinchCenter(e) {
                const rect = container.getBoundingClientRect();
                const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                return { x: cx - rect.left, y: cy - rect.top };
            }

            function handleStart(e) {
                // FIXED: Don't hijack touches on UI elements
                if (e.target.closest('.playground-ui') ||
                    e.target.closest('.zoom-controls') ||
                    e.target.closest('.back-btn')) {
                    return;
                }

                e.preventDefault();

                // Multi-touch Pinch Start
                if (e.touches && e.touches.length === 2) {
                    initialPinchDist = getPinchDist(e);
                    lastPinchZoom = camera.zoom;
                    // We also want to track center for panning during zoom? 
                    // For simplicity, just zoom relative to center
                    isDragging = false; // Disable drawing/panning while pinching
                    return;
                }

                const pos = getPointerPos(e);
                lastMouse = pos;
                isDragging = true;

                if (activeTool === 'pan' || (e.button === 1) || (e.type === 'mousedown' && e.shiftKey)) {
                    container.classList.add('panning');
                    return;
                }

                // Start Drawing
                const worldPos = toWorld(pos.x, pos.y);
                currentStroke = {
                    points: [worldPos],
                    color: currentColor,
                    size: currentSize,
                    isEraser: isEraser
                };
                render();
            }

            function handleMove(e) {
                e.preventDefault();

                // Multi-touch Pinch Move
                if (e.touches && e.touches.length === 2 && initialPinchDist) {
                    const dist = getPinchDist(e);
                    const center = getPinchCenter(e);
                    const dpr = window.devicePixelRatio || 1;

                    // Calculate Zoom Factor
                    const scale = dist / initialPinchDist;
                    let newZoom = lastPinchZoom * scale;
                    newZoom = Math.min(Math.max(newZoom, 0.1), 5);

                    // Zoom towards pinch center
                    // To do this strictly: 
                    // World point under center BEFORE zoom = World point under center AFTER zoom
                    // W = (Screen - CamOld) / ZoomOld
                    // W = (Screen - CamNew) / ZoomNew
                    // => CamNew = Screen - W * ZoomNew

                    const wx = (center.x * dpr - camera.x) / camera.zoom;
                    const wy = (center.y * dpr - camera.y) / camera.zoom;

                    camera.x = center.x * dpr - wx * newZoom;
                    camera.y = center.y * dpr - wy * newZoom;
                    camera.zoom = newZoom;

                    render();
                    return;
                }

                if (!isDragging) return;
                const pos = getPointerPos(e);

                if (activeTool === 'pan' || container.classList.contains('panning')) {
                    const dpr = window.devicePixelRatio || 1;
                    const dx = (pos.x - lastMouse.x) * dpr;
                    const dy = (pos.y - lastMouse.y) * dpr;
                    camera.x += dx;
                    camera.y += dy;
                    lastMouse = pos;
                    render();
                    return;
                }

                // Continue Drawing
                const worldPos = toWorld(pos.x, pos.y);
                if (currentStroke) {
                    currentStroke.points.push(worldPos);
                    render();
                }
                lastMouse = pos;
            }

            function handleEnd(e) {
                // Reset Pinch
                if (e.touches && e.touches.length < 2) {
                    initialPinchDist = null;
                }

                if (currentStroke) {
                    strokes.push(currentStroke);
                    currentStroke = null;
                }
                isDragging = false;
                container.classList.remove('panning');
                render();
            }

            function handleWheel(e) {
                e.preventDefault();
                const zoomIntensity = 0.1;
                const direction = e.deltaY > 0 ? -1 : 1;
                const factor = 1 + (direction * zoomIntensity);

                // Zoom focused on mouse pointer
                const pos = getPointerPos(e);
                const dpr = window.devicePixelRatio || 1;

                // Mouse in world coordinates before zoom
                const wx = (pos.x * dpr - camera.x) / camera.zoom;
                const wy = (pos.y * dpr - camera.y) / camera.zoom;

                let newZoom = camera.zoom * factor;
                newZoom = Math.min(Math.max(newZoom, 0.1), 5); // Clamp 10% to 500%

                // Adjust camera so consistent world point remains under mouse
                camera.x = pos.x * dpr - wx * newZoom;
                camera.y = pos.y * dpr - wy * newZoom;
                camera.zoom = newZoom;

                render();
            }

            // --- 5. EVENT LISTENERS ---
            container.addEventListener('mousedown', handleStart);
            window.addEventListener('mousemove', handleMove); // Window to catch drags outside
            window.addEventListener('mouseup', handleEnd);

            container.addEventListener('touchstart', handleStart, { passive: false });
            container.addEventListener('touchmove', handleMove, { passive: false });
            container.addEventListener('touchend', handleEnd);

            container.addEventListener('wheel', handleWheel, { passive: false });

            // --- 6. UI LOGIC ---
            const btnMarker = document.getElementById('btn-marker');
            const btnEraser = document.getElementById('btn-eraser');
            const btnPan = document.getElementById('btn-pan');
            const btns = [btnMarker, btnEraser, btnPan];
            const colorBtns = document.querySelectorAll('.color-btn');

            function activateTool(name) {
                activeTool = name;
                btns.forEach(b => b.classList.remove('active'));

                // Reset Cursor
                container.style.cursor = 'crosshair';

                if (name === 'marker') {
                    btnMarker.classList.add('active');
                    isEraser = false;
                    container.style.cursor = 'crosshair';
                } else if (name === 'eraser') {
                    btnEraser.classList.add('active');
                    isEraser = true;
                    // Custom Circle Eraser Cursor using SVG
                    // Circle with cross to indicate erasing area
                    const eraserSvg = `<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'><circle cx='16' cy='16' r='14' fill='none' stroke='black' stroke-width='2'/><line x1='8' y1='16' x2='24' y2='16' stroke='black' stroke-width='1'/></svg>`;
                    container.style.cursor = `url('data:image/svg+xml;utf8,${encodeURIComponent(eraserSvg)}') 16 16, auto`;
                } else if (name === 'pan') {
                    btnPan.classList.add('active');
                    container.style.cursor = 'grab';
                }
            }

            btnMarker.addEventListener('click', () => activateTool('marker'));
            btnEraser.addEventListener('click', () => activateTool('eraser'));
            btnPan.addEventListener('click', () => activateTool('pan'));

            colorBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    colorBtns.forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentColor = e.target.dataset.color;
                    activateTool('marker'); // Auto switch back to marker on color pick
                });
            });

            // Grid
            let isGridOn = false;
            document.getElementById('btn-grid').addEventListener('click', function () {
                isGridOn = !isGridOn;
                gridLayer.classList.toggle('visible', isGridOn);
                this.classList.toggle('active', isGridOn);
                this.querySelector('span').innerText = isGridOn ? 'Grid On' : 'Grid Off';
            });

            // Clear
            document.getElementById('btn-clear').addEventListener('click', () => {
                strokes = [];
                render();
            });

            // Zoom Buttons
            document.getElementById('btn-zoom-in').addEventListener('click', () => {
                camera.zoom = Math.min(camera.zoom * 1.2, 5);
                render();
            });
            document.getElementById('btn-zoom-out').addEventListener('click', () => {
                camera.zoom = Math.max(camera.zoom / 1.2, 0.1);
                render();
            });
            document.getElementById('btn-zoom-reset').addEventListener('click', () => {
                camera.zoom = 1;
                camera.x = 0;
                camera.y = 0;
                render();
            });

            // Save (Advanced: Render everything to a temp canvas)
            document.getElementById('btn-save').addEventListener('click', () => {
                // Determine bounds of drawing
                if (strokes.length === 0) { alert("Nothing to save!"); return; }

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                strokes.forEach(s => {
                    s.points.forEach(p => {
                        if (p.x < minX) minX = p.x;
                        if (p.x > maxX) maxX = p.x;
                        if (p.y < minY) minY = p.y;
                        if (p.y > maxY) maxY = p.y;
                    });
                });

                // Add padding
                const padding = 50;
                minX -= padding; minY -= padding;
                maxX += padding; maxY += padding;
                const w = maxX - minX;
                const h = maxY - minY;

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = w;
                tempCanvas.height = h;
                const tCtx = tempCanvas.getContext('2d');

                // Fill white
                tCtx.fillStyle = '#f4f4f4';
                tCtx.fillRect(0, 0, w, h);

                // Draw strokes shifted by minX, minY
                tCtx.translate(-minX, -minY);

                // Re-use draw logic (simplified inline)
                strokes.forEach(stroke => {
                    tCtx.lineWidth = stroke.size;
                    tCtx.lineCap = 'round';
                    tCtx.lineJoin = 'round';
                    if (stroke.isEraser) {
                        tCtx.globalCompositeOperation = 'destination-out'; // Won't work perfect on white bg fill, but okay for now
                        // Actually, for save to image with white bg, eraser should paint WHITE
                        tCtx.globalCompositeOperation = 'source-over';
                        tCtx.strokeStyle = '#f4f4f4';
                    } else {
                        tCtx.globalCompositeOperation = 'source-over';
                        tCtx.strokeStyle = stroke.color;
                    }

                    tCtx.beginPath();
                    tCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
                    for (let i = 1; i < stroke.points.length - 2; i++) {
                        const c = (stroke.points[i].x + stroke.points[i + 1].x) / 2;
                        const d = (stroke.points[i].y + stroke.points[i + 1].y) / 2;
                        tCtx.quadraticCurveTo(stroke.points[i].x, stroke.points[i].y, c, d);
                    }
                    const i = stroke.points.length - 2;
                    if (stroke.points.length > 2)
                        tCtx.quadraticCurveTo(stroke.points[i].x, stroke.points[i].y, stroke.points[i + 1].x, stroke.points[i + 1].y);
                    else
                        tCtx.lineTo(stroke.points[0].x, stroke.points[0].y);
                    tCtx.stroke();
                });

                const link = document.createElement('a');
                link.download = `marker-sketch-infinite-${Date.now()}.png`;
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
            });

            // Key Shortcuts
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') activateTool('pan');
                if (e.key === 'm') activateTool('marker');
                if (e.key === 'e') activateTool('eraser');
                if (e.key === 'g') document.getElementById('btn-grid').click();
                if (e.key === 's') document.getElementById('btn-save').click();
            });
            window.addEventListener('keyup', (e) => {
                if (e.code === 'Space') activateTool('marker'); // Revert to marker on release? standard UX varies
            });

            // Initial Render
            render();
        }

        document.addEventListener("DOMContentLoaded", () => {
            initPlayground();

            // --- TRANSITION LOGIC ---
            const overlay = document.querySelector('.transition-overlay');

            // 1. Entrance Reveal (Slide Curtain Up)
            if (overlay) {
                gsap.to(overlay, {
                    scaleY: 0,
                    duration: 1,
                    ease: "power4.inOut",
                    delay: 0.2
                });
            }

            // 2. Return Home Logic
            window.goHome = function (e) {
                e.preventDefault();
                if (overlay) {
                    gsap.set(overlay, { transformOrigin: "bottom" }); // Ensure it rises from bottom (or falls from top? User wants smooth return)
                    // Let's make it fall from top for variety? Or consistent bottom-up?
                    // "Return Home" -> maybe reverse direction? 
                    // Let's stick to "Curtain Close" (Bottom Up) for consistency with Index
                    gsap.to(overlay, {
                        scaleY: 1,
                        duration: 0.8,
                        ease: "power4.inOut",
                        onComplete: () => {
                            window.location.href = 'index.html';
                        }
                    });
                } else {
                    window.location.href = 'index.html';
                }
            };
        });
    </script>
</body>

</html>